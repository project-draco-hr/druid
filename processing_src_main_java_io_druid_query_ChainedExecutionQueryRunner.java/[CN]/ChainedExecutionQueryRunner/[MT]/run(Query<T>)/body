{
  final int priority=query.getContextPriority(0);
  return new BaseSequence<T,Iterator<T>>(new BaseSequence.IteratorMaker<T,Iterator<T>>(){
    @Override public Iterator<T> make(){
      List<Future<List<T>>> futures=Lists.newArrayList(Iterables.transform(queryables,new Function<QueryRunner<T>,Future<List<T>>>(){
        @Override public Future<List<T>> apply(        final QueryRunner<T> input){
          return exec.submit(new PrioritizedCallable<List<T>>(priority){
            @Override public List<T> call() throws Exception {
              try {
                if (input == null) {
                  throw new ISE("Input is null?! How is this possible?!");
                }
                Sequence<T> result=input.run(query);
                if (result == null) {
                  throw new ISE("Got a null result! Segments are missing!");
                }
                List<T> retVal=Sequences.toList(result,Lists.<T>newArrayList());
                if (retVal == null) {
                  throw new ISE("Got a null list of results! WTF?!");
                }
                return retVal;
              }
 catch (              Exception e) {
                log.error(e,"Exception with one of the sequences!");
                throw Throwables.propagate(e);
              }
            }
          }
);
        }
      }
));
      return new MergeIterable<T>(ordering.nullsFirst(),Iterables.transform(futures,new Function<Future<List<T>>,Iterable<T>>(){
        @Override public Iterable<T> apply(        Future<List<T>> input){
          try {
            return input.get();
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
catch (          ExecutionException e) {
            throw new RuntimeException(e);
          }
        }
      }
)).iterator();
    }
    @Override public void cleanup(    Iterator<T> tIterator){
    }
  }
);
}
