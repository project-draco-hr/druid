{
  row=formatRow(row);
  if (row.getTimestampFromEpoch() < minTimestamp) {
    throw new IAE("Cannot add row[%s] because it is below the minTimestamp[%s]",row,new DateTime(minTimestamp));
  }
  final List<String> rowDimensions=row.getDimensions();
  String[][] dims;
  List<String[]> overflow=null;
synchronized (dimensionOrder) {
    dims=new String[dimensionOrder.size()][];
    for (    String dimension : rowDimensions) {
      List<String> dimensionValues=row.getDimension(dimension);
      ColumnCapabilitiesImpl capabilities=columnCapabilities.get(dimension);
      if (capabilities == null) {
        capabilities=new ColumnCapabilitiesImpl();
        capabilities.setType(ValueType.STRING);
        columnCapabilities.put(dimension,capabilities);
      }
      if (dimensionValues.size() > 1) {
        capabilities.setHasMultipleValues(true);
      }
      Integer index=dimensionOrder.get(dimension);
      if (index == null) {
        dimensionOrder.put(dimension,dimensionOrder.size());
        dimensions.add(dimension);
        if (overflow == null) {
          overflow=Lists.newArrayList();
        }
        overflow.add(getDimVals(dimValues.add(dimension),dimensionValues));
      }
 else {
        dims[index]=getDimVals(dimValues.get(dimension),dimensionValues);
      }
    }
  }
  if (overflow != null) {
    String[][] newDims=new String[dims.length + overflow.size()][];
    System.arraycopy(dims,0,newDims,0,dims.length);
    for (int i=0; i < overflow.size(); ++i) {
      newDims[dims.length + i]=overflow.get(i);
    }
    dims=newDims;
  }
  final TimeAndDims key=new TimeAndDims(Math.max(gran.truncate(row.getTimestampFromEpoch()),minTimestamp),dims);
  Integer rowOffset;
synchronized (this) {
    rowOffset=numEntries.get();
    final Integer prev=facts.putIfAbsent(key,rowOffset);
    if (prev != null) {
      rowOffset=prev;
    }
 else {
      Aggregator[] aggs=new Aggregator[metrics.length];
      for (int i=0; i < metrics.length; i++) {
        final AggregatorFactory agg=metrics[i];
        aggs[i]=agg.factorize(new ColumnSelectorFactory(){
          @Override public LongColumnSelector makeLongColumnSelector(          final String columnName){
            if (columnName.equals(Column.TIME_COLUMN_NAME)) {
              return new LongColumnSelector(){
                @Override public long get(){
                  return in.get().getTimestampFromEpoch();
                }
              }
;
            }
            return new LongColumnSelector(){
              @Override public long get(){
                return in.get().getLongMetric(columnName);
              }
            }
;
          }
          @Override public FloatColumnSelector makeFloatColumnSelector(          final String columnName){
            return new FloatColumnSelector(){
              @Override public float get(){
                return in.get().getFloatMetric(columnName);
              }
            }
;
          }
          @Override public ObjectColumnSelector makeObjectColumnSelector(          final String column){
            final String typeName=agg.getTypeName();
            final ObjectColumnSelector<Object> rawColumnSelector=new ObjectColumnSelector<Object>(){
              @Override public Class classOfObject(){
                return Object.class;
              }
              @Override public Object get(){
                return in.get().getRaw(column);
              }
            }
;
            if (!deserializeComplexMetrics) {
              return rawColumnSelector;
            }
 else {
              if (typeName.equals("float")) {
                return rawColumnSelector;
              }
              final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(typeName);
              if (serde == null) {
                throw new ISE("Don't know how to handle type[%s]",typeName);
              }
              final ComplexMetricExtractor extractor=serde.getExtractor();
              return new ObjectColumnSelector(){
                @Override public Class classOfObject(){
                  return extractor.extractedClass();
                }
                @Override public Object get(){
                  return extractor.extractValue(in.get(),column);
                }
              }
;
            }
          }
          @Override public DimensionSelector makeDimensionSelector(          final String dimension){
            return new DimensionSelector(){
              @Override public IndexedInts getRow(){
                final List<String> dimensionValues=in.get().getDimension(dimension);
                final ArrayList<Integer> vals=Lists.newArrayList();
                if (dimensionValues != null) {
                  for (int i=0; i < dimensionValues.size(); ++i) {
                    vals.add(i);
                  }
                }
                return new IndexedInts(){
                  @Override public int size(){
                    return vals.size();
                  }
                  @Override public int get(                  int index){
                    return vals.get(index);
                  }
                  @Override public Iterator<Integer> iterator(){
                    return vals.iterator();
                  }
                }
;
              }
              @Override public int getValueCardinality(){
                throw new UnsupportedOperationException("value cardinality is unknown in incremental index");
              }
              @Override public String lookupName(              int id){
                return in.get().getDimension(dimension).get(id);
              }
              @Override public int lookupId(              String name){
                return in.get().getDimension(dimension).indexOf(name);
              }
            }
;
          }
        }
);
      }
      aggList.add(aggs);
      numEntries.incrementAndGet();
    }
  }
  in.set(row);
  Aggregator[] aggs=aggList.get(rowOffset);
  for (int i=0; i < aggs.length; i++) {
synchronized (aggs[i]) {
      aggs[i].aggregate();
    }
  }
  in.set(null);
  return numEntries.get();
}
