{
synchronized (tasks) {
    if (!tasks.containsKey(task.getId())) {
      tasks.put(task.getId(),new ForkingTaskRunnerWorkItem(task,exec.submit(new Callable<TaskStatus>(){
        @Override public TaskStatus call(){
          final String attemptUUID=UUID.randomUUID().toString();
          final File taskDir=new File(config.getTaskDir(),task.getId());
          final File attemptDir=new File(taskDir,attemptUUID);
          final ProcessHolder processHolder;
          try {
            final Closer closer=Closer.create();
            try {
              if (!attemptDir.mkdirs()) {
                throw new IOException(String.format("Could not create directories: %s",attemptDir));
              }
              final File taskFile=new File(attemptDir,"task.json");
              final File statusFile=new File(attemptDir,"status.json");
              final File logFile=new File(attemptDir,"log");
synchronized (tasks) {
                final ForkingTaskRunnerWorkItem taskWorkItem=tasks.get(task.getId());
                if (taskWorkItem.shutdown) {
                  throw new IllegalStateException("Task has been shut down!");
                }
                if (taskWorkItem == null) {
                  log.makeAlert("WTF?! TaskInfo disappeared!").addData("task",task.getId()).emit();
                  throw new ISE("TaskInfo disappeared for task[%s]!",task.getId());
                }
                if (taskWorkItem.processHolder != null) {
                  log.makeAlert("WTF?! TaskInfo already has a processHolder").addData("task",task.getId()).emit();
                  throw new ISE("TaskInfo already has processHolder for task[%s]!",task.getId());
                }
                final List<String> command=Lists.newArrayList();
                final int childPort=findUnusedPort();
                final String childHost=String.format("%s:%d",node.getHostNoPort(),childPort);
                command.add(config.getJavaCommand());
                command.add("-cp");
                command.add(config.getClasspath());
                Iterables.addAll(command,whiteSpaceSplitter.split(config.getJavaOpts()));
                for (                String propName : props.stringPropertyNames()) {
                  for (                  String allowedPrefix : config.getAllowedPrefixes()) {
                    if (propName.startsWith(allowedPrefix)) {
                      command.add(String.format("-D%s=%s",propName,props.getProperty(propName)));
                    }
                  }
                }
                for (                String propName : props.stringPropertyNames()) {
                  if (propName.startsWith(CHILD_PROPERTY_PREFIX)) {
                    command.add(String.format("-D%s=%s",propName.substring(CHILD_PROPERTY_PREFIX.length()),props.getProperty(propName)));
                  }
                }
                command.add(String.format("-Ddruid.host=%s",childHost));
                command.add(String.format("-Ddruid.port=%d",childPort));
                command.add("io.druid.cli.Main");
                command.add("internal");
                command.add("peon");
                command.add(taskFile.toString());
                command.add(statusFile.toString());
                String nodeType=task.getNodeType();
                if (nodeType != null) {
                  command.add(String.format("--nodeType %s",nodeType));
                }
                jsonMapper.writeValue(taskFile,task);
                log.info("Running command: %s",Joiner.on(" ").join(command));
                taskWorkItem.processHolder=new ProcessHolder(new ProcessBuilder(ImmutableList.copyOf(command)).redirectErrorStream(true).start(),logFile,childPort);
                processHolder=taskWorkItem.processHolder;
                processHolder.registerWithCloser(closer);
              }
              log.info("Logging task %s output to: %s",task.getId(),logFile);
              final InputStream fromProc=processHolder.process.getInputStream();
              final OutputStream toLogfile=closer.register(Files.newOutputStreamSupplier(logFile).getOutput());
              boolean runFailed=true;
              ByteStreams.copy(fromProc,toLogfile);
              final int statusCode=processHolder.process.waitFor();
              log.info("Process exited with status[%d] for task: %s",statusCode,task.getId());
              if (statusCode == 0) {
                runFailed=false;
              }
              taskLogPusher.pushTaskLog(task.getId(),logFile);
              if (!runFailed) {
                return jsonMapper.readValue(statusFile,TaskStatus.class);
              }
 else {
                return TaskStatus.failure(task.getId());
              }
            }
 catch (            Throwable t) {
              throw closer.rethrow(t);
            }
 finally {
              closer.close();
            }
          }
 catch (          Exception e) {
            log.info(e,"Exception caught during execution");
            throw Throwables.propagate(e);
          }
 finally {
            try {
synchronized (tasks) {
                final ForkingTaskRunnerWorkItem taskWorkItem=tasks.remove(task.getId());
                if (taskWorkItem != null && taskWorkItem.processHolder != null) {
                  taskWorkItem.processHolder.process.destroy();
                }
              }
              log.info("Removing temporary directory: %s",attemptDir);
              FileUtils.deleteDirectory(attemptDir);
            }
 catch (            Exception e) {
              log.error(e,"Suppressing exception caught while cleaning up task");
            }
          }
        }
      }
)));
    }
    return tasks.get(task.getId()).getResult();
  }
}
