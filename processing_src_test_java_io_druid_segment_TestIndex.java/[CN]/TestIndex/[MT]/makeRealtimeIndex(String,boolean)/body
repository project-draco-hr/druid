{
  final URL resource=TestIndex.class.getClassLoader().getResource(resourceFilename);
  log.info("Realtime loading index file[%s]",resource);
  final IncrementalIndexSchema schema=new IncrementalIndexSchema.Builder().withMinTimestamp(new DateTime("2011-01-12T00:00:00.000Z").getMillis()).withQueryGranularity(QueryGranularity.NONE).withMetrics(METRIC_AGGS).build();
  final IncrementalIndex retVal;
  if (useOffheap) {
    retVal=new OffheapIncrementalIndex(schema,TestQueryRunners.pool,true);
  }
 else {
    retVal=new OnheapIncrementalIndex(schema);
  }
  final AtomicLong startTime=new AtomicLong();
  int lineCount;
  try {
    lineCount=CharStreams.readLines(CharStreams.newReaderSupplier(new InputSupplier<InputStream>(){
      @Override public InputStream getInput() throws IOException {
        return resource.openStream();
      }
    }
,Charsets.UTF_8),new LineProcessor<Integer>(){
      StringInputRowParser parser=new StringInputRowParser(new DelimitedParseSpec(new TimestampSpec("ts","iso"),new DimensionsSpec(Arrays.asList(DIMENSIONS),null,null),"\t","\u0001",Arrays.asList(COLUMNS)));
      boolean runOnce=false;
      int lineCount=0;
      @Override public boolean processLine(      String line) throws IOException {
        if (!runOnce) {
          startTime.set(System.currentTimeMillis());
          runOnce=true;
        }
        retVal.add(parser.parse(line));
        ++lineCount;
        return true;
      }
      @Override public Integer getResult(){
        return lineCount;
      }
    }
);
  }
 catch (  IOException e) {
    realtimeIndex=null;
    throw Throwables.propagate(e);
  }
  log.info("Loaded %,d lines in %,d millis.",lineCount,System.currentTimeMillis() - startTime.get());
  return retVal;
}
