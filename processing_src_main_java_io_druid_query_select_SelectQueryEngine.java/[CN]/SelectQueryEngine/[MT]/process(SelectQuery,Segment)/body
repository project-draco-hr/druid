{
  final StorageAdapter adapter=segment.asStorageAdapter();
  if (adapter == null) {
    throw new ISE("Null storage adapter found. Probably trying to issue a query against a segment being memory unmapped.");
  }
  final Iterable<String> dims;
  if (query.getDimensions() == null || query.getDimensions().isEmpty()) {
    dims=adapter.getAvailableDimensions();
  }
 else {
    dims=query.getDimensions();
  }
  final Iterable<String> metrics;
  if (query.getMetrics() == null || query.getMetrics().isEmpty()) {
    metrics=adapter.getAvailableMetrics();
  }
 else {
    metrics=query.getMetrics();
  }
  return QueryRunnerHelper.makeCursorBasedQuery(adapter,query.getQuerySegmentSpec().getIntervals(),Filters.convertDimensionFilters(query.getDimensionsFilter()),query.getGranularity(),new Function<Cursor,Result<SelectResultValue>>(){
    @Override public Result<SelectResultValue> apply(    Cursor cursor){
      final SelectResultValueBuilder builder=new SelectResultValueBuilder(cursor.getTime(),query.getPagingSpec().getThreshold());
      final LongColumnSelector timestampColumnSelector=cursor.makeLongColumnSelector(Column.TIME_COLUMN_NAME);
      final Map<String,DimensionSelector> dimSelectors=Maps.newHashMap();
      for (      String dim : dims) {
        final DimensionSelector dimSelector=cursor.makeDimensionSelector(new DefaultDimensionSpec(dim,dim));
        dimSelectors.put(dim,dimSelector);
      }
      final Map<String,ObjectColumnSelector> metSelectors=Maps.newHashMap();
      for (      String metric : metrics) {
        final ObjectColumnSelector metricSelector=cursor.makeObjectColumnSelector(metric);
        metSelectors.put(metric,metricSelector);
      }
      int startOffset;
      if (query.getPagingSpec().getPagingIdentifiers() == null) {
        startOffset=0;
      }
 else {
        Integer offset=query.getPagingSpec().getPagingIdentifiers().get(segment.getIdentifier());
        startOffset=(offset == null) ? 0 : offset;
      }
      cursor.advanceTo(startOffset);
      int offset=0;
      while (!cursor.isDone() && offset < query.getPagingSpec().getThreshold()) {
        final Map<String,Object> theEvent=Maps.newLinkedHashMap();
        theEvent.put(EventHolder.timestampKey,new DateTime(timestampColumnSelector.get()));
        for (        Map.Entry<String,DimensionSelector> dimSelector : dimSelectors.entrySet()) {
          final String dim=dimSelector.getKey();
          final DimensionSelector selector=dimSelector.getValue();
          if (selector == null) {
            theEvent.put(dim,null);
          }
 else {
            final IndexedInts vals=selector.getRow();
            if (vals.size() == 1) {
              final String dimVal=selector.lookupName(vals.get(0));
              theEvent.put(dim,dimVal);
            }
 else {
              List<String> dimVals=Lists.newArrayList();
              for (int i=0; i < vals.size(); ++i) {
                dimVals.add(selector.lookupName(vals.get(i)));
              }
              theEvent.put(dim,dimVals);
            }
          }
        }
        for (        Map.Entry<String,ObjectColumnSelector> metSelector : metSelectors.entrySet()) {
          final String metric=metSelector.getKey();
          final ObjectColumnSelector selector=metSelector.getValue();
          if (selector == null) {
            theEvent.put(metric,null);
          }
 else {
            theEvent.put(metric,selector.get());
          }
        }
        builder.addEntry(new EventHolder(segment.getIdentifier(),startOffset + offset,theEvent));
        cursor.advance();
        offset++;
      }
      return builder.build();
    }
  }
);
}
