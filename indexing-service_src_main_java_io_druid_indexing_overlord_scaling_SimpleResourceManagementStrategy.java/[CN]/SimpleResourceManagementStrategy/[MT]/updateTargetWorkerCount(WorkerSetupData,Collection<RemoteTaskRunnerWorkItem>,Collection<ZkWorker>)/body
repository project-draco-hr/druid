{
synchronized (lock) {
    final Collection<ZkWorker> validWorkers=Collections2.filter(zkWorkers,createValidWorkerPredicate(config,workerSetupData));
    final Predicate<ZkWorker> isLazyWorker=createLazyWorkerPredicate(config,workerSetupData);
    final int minWorkerCount=workerSetupData.getMinNumWorkers();
    final int maxWorkerCount=workerSetupData.getMaxNumWorkers();
    if (minWorkerCount > maxWorkerCount) {
      log.info("Huh? minWorkerCount[%d] > maxWorkerCount[%d]. I give up!",minWorkerCount,maxWorkerCount);
    }
    if (targetWorkerCount < 0) {
      targetWorkerCount=Math.max(Math.min(zkWorkers.size(),maxWorkerCount),minWorkerCount);
      log.info("Starting with a target of %,d workers (current = %,d, min = %,d, max = %,d).",targetWorkerCount,validWorkers.size(),minWorkerCount,maxWorkerCount);
    }
    final boolean atSteadyState=currentlyProvisioning.isEmpty() && currentlyTerminating.isEmpty() && validWorkers.size() == targetWorkerCount;
    final boolean shouldScaleUp=atSteadyState && targetWorkerCount < maxWorkerCount && (hasTaskPendingBeyondThreshold(pendingTasks) || targetWorkerCount < minWorkerCount);
    final boolean shouldScaleDown=atSteadyState && targetWorkerCount > minWorkerCount && Iterables.any(validWorkers,isLazyWorker);
    if (shouldScaleUp) {
      targetWorkerCount=Math.max(targetWorkerCount + 1,minWorkerCount);
      log.info("I think we should scale up to %,d workers (current = %,d, min = %,d, max = %,d).",targetWorkerCount,validWorkers.size(),minWorkerCount,maxWorkerCount);
    }
 else     if (shouldScaleDown) {
      targetWorkerCount=Math.min(targetWorkerCount - 1,maxWorkerCount);
      log.info("I think we should scale down to %,d workers (current = %,d, min = %,d, max = %,d).",targetWorkerCount,validWorkers.size(),minWorkerCount,maxWorkerCount);
    }
 else {
      log.info("Our target is %,d workers, and I'm okay with that (current = %,d, min = %,d, max = %,d).",targetWorkerCount,validWorkers.size(),minWorkerCount,maxWorkerCount);
    }
  }
}
