{
synchronized (lock) {
    boolean didProvision=false;
    final WorkerSetupData workerSetupData=workerSetupDataRef.get();
    final Predicate<ZkWorker> isValidWorker=createValidWorkerPredicate(workerSetupData);
    final int currValidWorkers=Collections2.filter(zkWorkers,isValidWorker).size();
    final List<String> workerNodeIds=autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.<ZkWorker,String>transform(zkWorkers,new Function<ZkWorker,String>(){
      @Override public String apply(      ZkWorker input){
        return input.getWorker().getIp();
      }
    }
)));
    currentlyProvisioning.removeAll(workerNodeIds);
    updateTargetWorkerCount(pendingTasks,zkWorkers);
    if (currentlyProvisioning.isEmpty()) {
      int want=targetWorkerCount - (currValidWorkers + currentlyProvisioning.size());
      while (want > 0) {
        final AutoScalingData provisioned=autoScalingStrategy.provision();
        if (provisioned == null) {
          break;
        }
 else {
          currentlyProvisioning.addAll(provisioned.getNodeIds());
          lastProvisionTime=new DateTime();
          scalingStats.addProvisionEvent(provisioned);
          want-=provisioned.getNodeIds().size();
          didProvision=true;
        }
      }
    }
 else {
      Duration durSinceLastProvision=new Duration(lastProvisionTime,new DateTime());
      log.info("%s provisioning. Current wait time: %s",currentlyProvisioning,durSinceLastProvision);
      if (durSinceLastProvision.isLongerThan(config.getMaxScalingDuration().toStandardDuration())) {
        log.makeAlert("Worker node provisioning taking too long!").addData("millisSinceLastProvision",durSinceLastProvision.getMillis()).addData("provisioningCount",currentlyProvisioning.size()).emit();
        List<String> nodeIps=autoScalingStrategy.idToIpLookup(Lists.newArrayList(currentlyProvisioning));
        autoScalingStrategy.terminate(nodeIps);
        currentlyProvisioning.clear();
      }
    }
    return didProvision;
  }
}
