{
synchronized (lock) {
    final WorkerSetupData workerSetupData=workerSetupDataRef.get();
    if (workerSetupData == null) {
      log.warn("No workerSetupData available, cannot terminate workers.");
      return false;
    }
    boolean didTerminate=false;
    final Set<String> workerNodeIds=Sets.newHashSet(autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(zkWorkers,new Function<ZkWorker,String>(){
      @Override public String apply(      ZkWorker input){
        return input.getWorker().getIp();
      }
    }
))));
    final Set<String> stillExisting=Sets.newHashSet();
    for (    String s : currentlyTerminating) {
      if (workerNodeIds.contains(s)) {
        stillExisting.add(s);
      }
    }
    currentlyTerminating.clear();
    currentlyTerminating.addAll(stillExisting);
    updateTargetWorkerCount(pendingTasks,zkWorkers);
    final Predicate<ZkWorker> isLazyWorker=createLazyWorkerPredicate(config,workerSetupData);
    if (currentlyTerminating.isEmpty()) {
      final int want=zkWorkers.size() - targetWorkerCount;
      if (want > 0) {
        final List<String> laziestWorkerIps=FluentIterable.from(zkWorkers).filter(isLazyWorker).limit(want).transform(new Function<ZkWorker,String>(){
          @Override public String apply(          ZkWorker zkWorker){
            return zkWorker.getWorker().getIp();
          }
        }
).toList();
        log.info("Terminating %,d workers (wanted %,d): %s",laziestWorkerIps.size(),want,Joiner.on(", ").join(laziestWorkerIps));
        final AutoScalingData terminated=autoScalingStrategy.terminate(laziestWorkerIps);
        if (terminated != null) {
          currentlyTerminating.addAll(terminated.getNodeIds());
          lastTerminateTime=new DateTime();
          scalingStats.addTerminateEvent(terminated);
          didTerminate=true;
        }
      }
    }
 else {
      Duration durSinceLastTerminate=new Duration(lastTerminateTime,new DateTime());
      log.info("%s terminating. Current wait time: %s",currentlyTerminating,durSinceLastTerminate);
      if (durSinceLastTerminate.isLongerThan(config.getMaxScalingDuration().toStandardDuration())) {
        log.makeAlert("Worker node termination taking too long!").addData("millisSinceLastTerminate",durSinceLastTerminate.getMillis()).addData("terminatingCount",currentlyTerminating.size()).emit();
        currentlyTerminating.clear();
      }
    }
    return didTerminate;
  }
}
