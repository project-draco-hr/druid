{
  if (adapter == null) {
    throw new SegmentMissingException("Null storage adapter found. Probably trying to issue a query against a segment being memory unmapped.");
  }
  return QueryRunnerHelper.makeCursorBasedQuery(adapter,query.getQuerySegmentSpec().getIntervals(),Filters.convertDimensionFilters(query.getDimensionsFilter()),query.getGranularity(),new Function<Cursor,Result<TimeseriesResultValue>>(){
    private final List<AggregatorFactory> aggregatorSpecs=query.getAggregatorSpecs();
    @Override public Result<TimeseriesResultValue> apply(    Cursor cursor){
      Aggregator[] aggregators=QueryRunnerHelper.makeAggregators(cursor,aggregatorSpecs);
      try {
        final int aggSize=aggregators.length;
        final int aggExtra=aggSize % AGG_UNROLL_COUNT;
        while (!cursor.isDone()) {
switch (aggExtra) {
case 7:
            aggregators[6].aggregate();
case 6:
          aggregators[5].aggregate();
case 5:
        aggregators[4].aggregate();
case 4:
      aggregators[3].aggregate();
case 3:
    aggregators[2].aggregate();
case 2:
  aggregators[1].aggregate();
case 1:
aggregators[0].aggregate();
}
for (int j=aggExtra; j < aggSize; j+=AGG_UNROLL_COUNT) {
aggregators[j].aggregate();
aggregators[j + 1].aggregate();
aggregators[j + 2].aggregate();
aggregators[j + 3].aggregate();
aggregators[j + 4].aggregate();
aggregators[j + 5].aggregate();
aggregators[j + 6].aggregate();
aggregators[j + 7].aggregate();
}
cursor.advance();
}
TimeseriesResultBuilder bob=new TimeseriesResultBuilder(cursor.getTime());
for (Aggregator aggregator : aggregators) {
bob.addMetric(aggregator);
}
Result<TimeseriesResultValue> retVal=bob.build();
return retVal;
}
  finally {
for (Aggregator agg : aggregators) {
agg.close();
}
}
}
}
);
}
