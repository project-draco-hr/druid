{
  final BlockingQueue<Map<String,Object>> queue=new ArrayBlockingQueue<Map<String,Object>>(QUEUE_SIZE);
  Runnable updateStream=new UpdateStream(new WebJsonSupplier(dimensions,url),queue,new DefaultObjectMapper());
  final ExecutorService service=Executors.newSingleThreadExecutor();
  service.submit(updateStream);
  return new Firehose(){
    private final Runnable doNothingRunnable=Runnables.getNoopRunnable();
    @Override public boolean hasMore(){
      return !(service.isTerminated());
    }
    @Override public InputRow nextRow(){
      try {
        Map<String,Object> processedMap=processMap(queue.take());
        DateTime date=TimestampParser.createTimestampParser("auto").apply(processedMap.get(timeDimension).toString());
        long seconds=(long)date.getMillis();
        if (new DateTime(seconds * 1000).getYear() == new DateTime().getYear()) {
          seconds=(long)date.getMillis() * 1000;
        }
        return new MapBasedInputRow(seconds,renamedDimensions,processedMap);
      }
 catch (      Exception e) {
        throw Throwables.propagate(e);
      }
    }
    private Map<String,Object> renameKeys(    Map<String,Object> update){
      Map<String,Object> renamedMap=Maps.newHashMap();
      for (int iter=0; iter < dimensions.size(); iter++) {
        if (update.get(dimensions.get(iter)) != null) {
          Object obj=update.get(dimensions.get(iter));
          renamedMap.put(renamedDimensions.get(iter),obj);
        }
      }
      if (renamedMap.get(timeDimension) == null) {
        renamedMap.put(timeDimension,System.currentTimeMillis());
      }
      return renamedMap;
    }
    private Map<String,Object> processMap(    Map<String,Object> map){
      Map<String,Object> renamedMap=renameKeys(map);
      return renamedMap;
    }
    @Override public Runnable commit(){
      return doNothingRunnable;
    }
    @Override public void close() throws IOException {
      service.shutdown();
    }
  }
;
}
