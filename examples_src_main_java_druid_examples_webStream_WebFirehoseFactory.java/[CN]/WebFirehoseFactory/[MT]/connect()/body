{
  final int QUEUE_SIZE=2000;
  final BlockingQueue<Map<String,Object>> queue=new ArrayBlockingQueue<Map<String,Object>>(QUEUE_SIZE);
  Runnable updateStream=new UpdateStream(new WebJsonSupplier(dimensions,url),queue);
  final ExecutorService service=Executors.newSingleThreadExecutor();
  service.submit(updateStream);
  return new Firehose(){
    private final Runnable doNothingRunnable=new NoopRunnable();
    @Override public boolean hasMore(){
      return !(service.isTerminated());
    }
    @Override public InputRow nextRow(){
      if (Thread.currentThread().isInterrupted()) {
        throw new RuntimeException("Interrupted, time to stop");
      }
      Map<String,Object> update;
      try {
        update=queue.take();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("InterrutpedException",e);
      }
      Map<String,Object> processedMap=processMap(update);
      return new MapBasedInputRow(((Integer)processedMap.get(timeDimension)).longValue() * 1000,renamedDimensions,processedMap);
    }
    private Map<String,Object> renameKeys(    Map<String,Object> update){
      Map<String,Object> renamedMap=new HashMap<String,Object>();
      int iter=0;
      while (iter < dimensions.size()) {
        Object obj=update.get(dimensions.get(iter));
        renamedMap.put(renamedDimensions.get(iter),obj);
        iter++;
      }
      return renamedMap;
    }
    private void processNullDimensions(    Map<String,Object> map){
      for (      String key : renamedDimensions) {
        if (map.get(key) == null) {
          if (key.equals(timeDimension)) {
            map.put(key,new Integer((int)System.currentTimeMillis() / 1000));
          }
 else {
            map.put(key,null);
          }
        }
      }
    }
    private Map<String,Object> processMap(    Map<String,Object> map){
      Map<String,Object> renamedMap=renameKeys(map);
      processNullDimensions(renamedMap);
      return renamedMap;
    }
    @Override public Runnable commit(){
      return doNothingRunnable;
    }
    @Override public void close() throws IOException {
      log.info("CLOSING!!!");
      service.shutdown();
    }
  }
;
}
