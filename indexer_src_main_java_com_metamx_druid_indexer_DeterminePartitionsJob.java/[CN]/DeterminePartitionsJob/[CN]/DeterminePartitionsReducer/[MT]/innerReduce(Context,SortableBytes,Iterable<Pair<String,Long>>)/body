{
  PeekingIterator<Pair<String,Long>> iterator=Iterators.peekingIterator(combinedIterable.iterator());
  Pair<String,Long> totalPair=iterator.next();
  Preconditions.checkState(totalPair.lhs.equals(""),"Total pair value was[%s]!?",totalPair.lhs);
  long totalRows=totalPair.rhs;
  long numPartitions=Math.max(totalRows / config.getTargetPartitionSize(),1);
  long expectedRowsPerPartition=totalRows / numPartitions;
class PartitionsList extends ArrayList<ShardSpec> {
  }
  List<ShardSpec> partitions=new PartitionsList();
  runningTotal=0;
  Pair<String,Long> prev=null;
  previousBoundary=null;
  while (iterator.hasNext()) {
    Pair<String,Long> curr=iterator.next();
    if (runningTotal > expectedRowsPerPartition) {
      Preconditions.checkNotNull(prev,"Prev[null] while runningTotal[%s] was > expectedRows[%s]!?",runningTotal,expectedRowsPerPartition);
      addPartition(partitions,curr.lhs);
    }
    runningTotal+=curr.rhs;
    prev=curr;
  }
  if (partitions.isEmpty()) {
    partitions.add(new NoneShardSpec());
  }
 else   if (((double)runningTotal / (double)expectedRowsPerPartition) < 0.25) {
    final SingleDimensionShardSpec lastSpec=(SingleDimensionShardSpec)partitions.remove(partitions.size() - 1);
    partitions.add(new SingleDimensionShardSpec(config.getPartitionDimension(),lastSpec.getStart(),null,lastSpec.getPartitionNum()));
  }
 else {
    partitions.add(new SingleDimensionShardSpec(config.getPartitionDimension(),previousBoundary,null,partitions.size()));
  }
  DateTime bucket=new DateTime(Iterables.get(keySplitter.split(new String(keyBytes.getGroupKey(),Charsets.UTF_8)),0));
  OutputStream out=Utils.makePathAndOutputStream(context,config.makeSegmentPartitionInfoPath(new Bucket(0,bucket,0)),config.isOverwriteFiles());
  for (  ShardSpec partition : partitions) {
    log.info("%s",partition);
  }
  try {
    config.jsonMapper.writeValue(out,partitions);
  }
  finally {
    Closeables.close(out,false);
  }
}
