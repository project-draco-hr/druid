{
  Sequence<InputRow> rows=Sequences.concat(Iterables.transform(adapters,new Function<StorageAdapter,Sequence<InputRow>>(){
    @Nullable @Override public Sequence<InputRow> apply(    @Nullable StorageAdapter adapter){
      return Sequences.concat(Sequences.map(adapter.makeCursors(Filters.convertDimensionFilters(dimFilter),interval,QueryGranularity.ALL),new Function<Cursor,Sequence<InputRow>>(){
        @Nullable @Override public Sequence<InputRow> apply(        @Nullable Cursor cursor){
          TimestampColumnSelector timestampColumnSelector=cursor.makeTimestampColumnSelector();
          Map<String,DimensionSelector> dimSelectors=Maps.newHashMap();
          for (          String dim : dims) {
            final DimensionSelector dimSelector=cursor.makeDimensionSelector(dim);
            dimSelectors.put(dim,dimSelector);
          }
          Map<String,ObjectColumnSelector> metSelectors=Maps.newHashMap();
          for (          String metric : metrics) {
            final ObjectColumnSelector metricSelector=cursor.makeObjectColumnSelector(metric);
            metSelectors.put(metric,metricSelector);
          }
          List<InputRow> rowList=Lists.newArrayList();
          while (!cursor.isDone()) {
            final Map<String,Object> theEvent=Maps.newLinkedHashMap();
            final long timestamp=timestampColumnSelector.getTimestamp();
            theEvent.put(EventHolder.timestampKey,new DateTime(timestamp));
            for (            Map.Entry<String,DimensionSelector> dimSelector : dimSelectors.entrySet()) {
              final String dim=dimSelector.getKey();
              final DimensionSelector selector=dimSelector.getValue();
              final IndexedInts vals=selector.getRow();
              if (vals.size() == 1) {
                final String dimVal=selector.lookupName(vals.get(0));
                theEvent.put(dim,dimVal);
              }
 else {
                List<String> dimVals=Lists.newArrayList();
                for (int i=0; i < vals.size(); ++i) {
                  dimVals.add(selector.lookupName(vals.get(i)));
                }
                theEvent.put(dim,dimVals);
              }
            }
            for (            Map.Entry<String,ObjectColumnSelector> metSelector : metSelectors.entrySet()) {
              final String metric=metSelector.getKey();
              final ObjectColumnSelector selector=metSelector.getValue();
              theEvent.put(metric,selector.get());
            }
            rowList.add(new MapBasedInputRow(timestamp,dims,theEvent));
            cursor.advance();
          }
          return Sequences.simple(rowList);
        }
      }
));
    }
  }
));
  rowYielder=rows.toYielder(null,new YieldingAccumulator(){
    @Override public Object accumulate(    Object accumulated,    Object in){
      yield();
      return in;
    }
  }
);
}
