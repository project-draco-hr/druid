{
  if (segments.size() <= 1) {
    return segments;
  }
  final T min=segments.get(0);
  final T max=segments.get(segments.size() - 1);
  final Predicate<T> filterPredicate;
  if (query.getExclude().equalsIgnoreCase(TimeBoundaryQuery.MAX_TIME)) {
    filterPredicate=new Predicate<T>(){
      @Override public boolean apply(      T input){
        return input.getInterval().overlaps(min.getInterval());
      }
    }
;
  }
 else   if (query.getExclude().equalsIgnoreCase(TimeBoundaryQuery.MIN_TIME)) {
    filterPredicate=new Predicate<T>(){
      @Override public boolean apply(      T input){
        return input.getInterval().overlaps(max.getInterval());
      }
    }
;
  }
 else {
    filterPredicate=new Predicate<T>(){
      @Override public boolean apply(      T input){
        return input.getInterval().overlaps(min.getInterval()) || input.getInterval().overlaps(max.getInterval());
      }
    }
;
  }
  return Lists.newArrayList(Iterables.filter(segments,filterPredicate));
}
