{
  final int capacity=3;
  final ExecutorService executorService=Execs.newBlockingSingleThreaded("test%d",capacity);
  final AtomicInteger producedCount=new AtomicInteger();
  final AtomicInteger consumedCount=new AtomicInteger();
  final CyclicBarrier barrier=new CyclicBarrier(2);
  ExecutorService producer=Executors.newCachedThreadPool();
  producer.submit(new Runnable(){
    public void run(){
      for (int i=0; i < 2 * capacity; i++) {
        final int taskID=i;
        System.out.println("Produced task" + taskID);
        executorService.submit(new Runnable(){
          @Override public void run(){
            System.out.println("Starting task" + taskID);
            try {
              consumedCount.incrementAndGet();
              barrier.await();
              barrier.await();
            }
 catch (            Exception e) {
              throw Throwables.propagate(e);
            }
            System.out.println("Completed task" + taskID);
          }
        }
);
        producedCount.incrementAndGet();
      }
    }
  }
);
  while (producedCount.get() < capacity) {
    Thread.sleep(5);
  }
  for (int i=0; i < capacity; i++) {
    barrier.await();
    Assert.assertEquals(consumedCount.intValue() + capacity,producedCount.intValue());
    barrier.await();
  }
  for (int i=0; i < capacity; i++) {
    barrier.await();
  }
  producer.shutdown();
}
