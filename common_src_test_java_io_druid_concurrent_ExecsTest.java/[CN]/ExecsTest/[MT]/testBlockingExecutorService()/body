{
  final int capacity=3;
  final ExecutorService blockingExecutor=Execs.newBlockingSingleThreaded("test%d",capacity);
  final CountDownLatch queueFullSignal=new CountDownLatch(capacity + 1);
  final CountDownLatch taskCompletedSignal=new CountDownLatch(2 * capacity);
  final CountDownLatch taskStartSignal=new CountDownLatch(1);
  final AtomicInteger producedCount=new AtomicInteger();
  final AtomicInteger consumedCount=new AtomicInteger();
  ExecutorService producer=Executors.newSingleThreadExecutor();
  producer.submit(new Runnable(){
    public void run(){
      for (int i=0; i < 2 * capacity; i++) {
        final int taskID=i;
        System.out.println("Produced task" + taskID);
        blockingExecutor.submit(new Runnable(){
          @Override public void run(){
            System.out.println("Starting task" + taskID);
            try {
              taskStartSignal.await();
              consumedCount.incrementAndGet();
              taskCompletedSignal.countDown();
            }
 catch (            Exception e) {
              throw Throwables.propagate(e);
            }
            System.out.println("Completed task" + taskID);
          }
        }
);
        producedCount.incrementAndGet();
        queueFullSignal.countDown();
      }
    }
  }
);
  queueFullSignal.await();
  Assert.assertEquals(capacity + 1,producedCount.get());
  taskStartSignal.countDown();
  taskCompletedSignal.await();
  Assert.assertEquals(2 * capacity,consumedCount.get());
  blockingExecutor.shutdown();
  producer.shutdown();
}
