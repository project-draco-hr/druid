{
  final List<Interval> intervals=query.getQuerySegmentSpec().getIntervals();
  if (intervals.size() != 1) {
    throw new IAE("Should only have one interval, got[%s]",intervals);
  }
  final Iterable<Cursor> cursors=storageAdapter.makeCursors(Filters.convertDimensionFilters(query.getDimFilter()),intervals.get(0),query.getGranularity());
  final ResourceHolder<ByteBuffer> bufferHolder=intermediateResultsBufferPool.take();
  return new BaseSequence<Row,CloseableIterator<Row>>(new BaseSequence.IteratorMaker<Row,CloseableIterator<Row>>(){
    @Override public CloseableIterator<Row> make(){
      return new CloseableIterator<Row>(){
        final List<CloseableIterator> rowIterators=Lists.newLinkedList();
        final Iterator<Row> delegate=FunctionalIterator.create(cursors.iterator()).transformCat(new Function<Cursor,Iterator<Row>>(){
          @Override public Iterator<Row> apply(          @Nullable final Cursor cursor){
            RowIterator it=new RowIterator(query,cursor,bufferHolder.get());
            rowIterators.add(it);
            return it;
          }
        }
);
        @Override public void close(){
          for (          CloseableIterator it : rowIterators) {
            Closeables.closeQuietly(it);
          }
        }
        @Override public boolean hasNext(){
          return delegate.hasNext();
        }
        @Override public Row next(){
          return delegate.next();
        }
        @Override public void remove(){
          delegate.remove();
        }
      }
;
    }
    @Override public void cleanup(    CloseableIterator<Row> iterFromMake){
      Closeables.closeQuietly(iterFromMake);
      Closeables.closeQuietly(bufferHolder);
    }
  }
);
}
