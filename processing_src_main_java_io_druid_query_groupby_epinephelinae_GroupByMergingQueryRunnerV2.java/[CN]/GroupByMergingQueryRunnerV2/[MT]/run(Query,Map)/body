{
  final GroupByQuery query=(GroupByQuery)queryParam;
  final GroupByQueryConfig querySpecificConfig=config.withOverrides(query);
  final boolean forceChainedExecution=query.getContextBoolean(CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION,false);
  final GroupByQuery queryForRunners=query.withOverriddenContext(ImmutableMap.<String,Object>of(CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION,true));
  if (BaseQuery.getContextBySegment(query,false) || forceChainedExecution) {
    return new ChainedExecutionQueryRunner(exec,queryWatcher,queryables).run(query,responseContext);
  }
  final AggregatorFactory[] combiningAggregatorFactories=new AggregatorFactory[query.getAggregatorSpecs().size()];
  for (int i=0; i < query.getAggregatorSpecs().size(); i++) {
    combiningAggregatorFactories[i]=query.getAggregatorSpecs().get(i).getCombiningFactory();
  }
  final File temporaryStorageDirectory=new File(System.getProperty("java.io.tmpdir"),String.format("druid-groupBy-%s_%s",UUID.randomUUID(),query.getId()));
  final Number queryTimeout=query.getContextValue(QueryContextKeys.TIMEOUT,null);
  final long timeoutAt=queryTimeout == null ? JodaUtils.MAX_INSTANT : System.currentTimeMillis() + queryTimeout.longValue();
  return new BaseSequence<>(new BaseSequence.IteratorMaker<Row,CloseableGrouperIterator<GroupByMergingKey,Row>>(){
    @Override public CloseableGrouperIterator<GroupByMergingKey,Row> make(){
      final List<Closeable> closeOnFailure=Lists.newArrayList();
      try {
        final ReferenceCountingResourceHolder<ByteBuffer> mergeBufferHolder;
        final LimitedTemporaryStorage temporaryStorage;
        final Grouper<GroupByMergingKey> grouper;
        temporaryStorage=new LimitedTemporaryStorage(temporaryStorageDirectory,querySpecificConfig.getMaxOnDiskStorage());
        closeOnFailure.add(temporaryStorage);
        try {
          final long timeout=timeoutAt - System.currentTimeMillis();
          if (timeout <= 0 || (mergeBufferHolder=mergeBufferPool.take(timeout)) == null) {
            throw new QueryInterruptedException(new TimeoutException());
          }
          closeOnFailure.add(mergeBufferHolder);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          throw Throwables.propagate(e);
        }
        final GroupByMergingKeySerdeFactory keySerdeFactory=new GroupByMergingKeySerdeFactory(query.getDimensions().size(),querySpecificConfig.getMaxMergingDictionarySize() / concurrencyHint);
        final GroupByMergingColumnSelectorFactory columnSelectorFactory=new GroupByMergingColumnSelectorFactory();
        grouper=new ConcurrentGrouper<>(mergeBufferHolder.get(),concurrencyHint,temporaryStorage,spillMapper,querySpecificConfig.getBufferGrouperMaxSize(),querySpecificConfig.getBufferGrouperInitialBuckets(),keySerdeFactory,columnSelectorFactory,combiningAggregatorFactories);
        closeOnFailure.add(grouper);
        final Accumulator<Grouper<GroupByMergingKey>,Row> accumulator=new Accumulator<Grouper<GroupByMergingKey>,Row>(){
          @Override public Grouper<GroupByMergingKey> accumulate(          final Grouper<GroupByMergingKey> theGrouper,          final Row row){
            if (theGrouper == null) {
              return null;
            }
            final long timestamp=row.getTimestampFromEpoch();
            final String[] dimensions=new String[query.getDimensions().size()];
            for (int i=0; i < dimensions.length; i++) {
              final Object dimValue=row.getRaw(query.getDimensions().get(i).getOutputName());
              dimensions[i]=Strings.nullToEmpty((String)dimValue);
            }
            columnSelectorFactory.setRow(row);
            final boolean didAggregate=theGrouper.aggregate(new GroupByMergingKey(timestamp,dimensions));
            if (!didAggregate) {
              return null;
            }
            columnSelectorFactory.setRow(null);
            return theGrouper;
          }
        }
;
        final int priority=BaseQuery.getContextPriority(query,0);
        final ReferenceCountingResourceHolder<Grouper<GroupByMergingKey>> grouperHolder=new ReferenceCountingResourceHolder<>(grouper,new Closeable(){
          @Override public void close() throws IOException {
            grouper.close();
          }
        }
);
        ListenableFuture<List<Boolean>> futures=Futures.allAsList(Lists.newArrayList(Iterables.transform(queryables,new Function<QueryRunner<Row>,ListenableFuture<Boolean>>(){
          @Override public ListenableFuture<Boolean> apply(          final QueryRunner<Row> input){
            if (input == null) {
              throw new ISE("Null queryRunner! Looks to be some segment unmapping action happening");
            }
            final Releaser bufferReleaser=mergeBufferHolder.increment();
            try {
              final Releaser grouperReleaser=grouperHolder.increment();
              try {
                return exec.submit(new AbstractPrioritizedCallable<Boolean>(priority){
                  @Override public Boolean call() throws Exception {
                    try {
                      final Object retVal=input.run(queryForRunners,responseContext).accumulate(grouper,accumulator);
                      return retVal == grouper;
                    }
 catch (                    QueryInterruptedException e) {
                      throw e;
                    }
catch (                    Exception e) {
                      log.error(e,"Exception with one of the sequences!");
                      throw Throwables.propagate(e);
                    }
 finally {
                      grouperReleaser.close();
                      bufferReleaser.close();
                    }
                  }
                }
);
              }
 catch (              Exception e) {
                grouperReleaser.close();
                throw e;
              }
            }
 catch (            Exception e) {
              bufferReleaser.close();
              throw e;
            }
          }
        }
)));
        waitForFutureCompletion(query,futures,timeoutAt - System.currentTimeMillis());
        return new CloseableGrouperIterator<>(grouper,true,new Function<Grouper.Entry<GroupByMergingKey>,Row>(){
          @Override public Row apply(          Grouper.Entry<GroupByMergingKey> entry){
            Map<String,Object> theMap=Maps.newLinkedHashMap();
            for (int i=0; i < entry.getKey().getDimensions().length; i++) {
              theMap.put(query.getDimensions().get(i).getOutputName(),Strings.emptyToNull(entry.getKey().getDimensions()[i]));
            }
            for (int i=0; i < entry.getValues().length; i++) {
              theMap.put(query.getAggregatorSpecs().get(i).getName(),entry.getValues()[i]);
            }
            return new MapBasedRow(query.getGranularity().toDateTime(entry.getKey().getTimestamp()),theMap);
          }
        }
,new Closeable(){
          @Override public void close() throws IOException {
            grouperHolder.close();
            mergeBufferHolder.close();
            CloseQuietly.close(temporaryStorage);
          }
        }
);
      }
 catch (      Throwable e) {
        for (        Closeable closeable : Lists.reverse(closeOnFailure)) {
          CloseQuietly.close(closeable);
        }
        throw e;
      }
    }
    @Override public void cleanup(    CloseableGrouperIterator<GroupByMergingKey,Row> iterFromMake){
      iterFromMake.close();
    }
  }
);
}
