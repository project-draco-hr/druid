{
  ArrayList<Iterable<Rowboat>> boats=Lists.newArrayListWithCapacity(indexes.size());
  for (int i=0; i < indexes.size(); ++i) {
    final IndexableAdapter adapter=indexes.get(i);
    final int[] dimLookup=toLookupMap(adapter.getDimensionNames(),mergedDimensions);
    final int[] metricLookup=toLookupMap(adapter.getMetricNames(),mergedMetrics);
    Iterable<Rowboat> target=indexes.get(i).getRows();
    if (dimLookup != null || metricLookup != null) {
      target=Iterables.transform(target,new Function<Rowboat,Rowboat>(){
        @Override public Rowboat apply(        Rowboat input){
          int[][] newDims=input.getDims();
          if (dimLookup != null) {
            newDims=new int[mergedDimensions.size()][];
            int j=0;
            for (            int[] dim : input.getDims()) {
              newDims[dimLookup[j]]=dim;
              j++;
            }
          }
          Object[] newMetrics=input.getMetrics();
          if (metricLookup != null) {
            newMetrics=new Object[mergedMetrics.size()];
            int j=0;
            for (            Object met : input.getMetrics()) {
              newMetrics[metricLookup[j]]=met;
              j++;
            }
          }
          return new Rowboat(input.getTimestamp(),newDims,newMetrics,input.getRowNum());
        }
      }
);
    }
    boats.add(new MMappedIndexRowIterable(target,mergedDimensions,dimConversions.get(i),i,convertMissingDimsFlags));
  }
  return rowMergerFn.apply(boats);
}
