{
  FileUtils.deleteDirectory(outDir);
  if (!outDir.mkdirs()) {
    throw new ISE("Couldn't make outdir[%s].",outDir);
  }
  final List<String> mergedDimensions=IndexMerger.getMergedDimensions(adapters);
  final List<String> mergedMetrics=Lists.transform(IndexMerger.mergeIndexed(Lists.newArrayList(FunctionalIterable.create(adapters).transform(new Function<IndexableAdapter,Iterable<String>>(){
    @Override public Iterable<String> apply(    @Nullable IndexableAdapter input){
      return input.getMetricNames();
    }
  }
).concat(Arrays.<Iterable<String>>asList(new IndexMerger.AggFactoryStringIndexed(metricAggs))))),new Function<String,String>(){
    @Override public String apply(    @Nullable String input){
      return input;
    }
  }
);
  if (mergedMetrics.size() != metricAggs.length) {
    throw new IAE("Bad number of metrics[%d], expected [%d]",mergedMetrics.size(),metricAggs.length);
  }
  final AggregatorFactory[] sortedMetricAggs=new AggregatorFactory[mergedMetrics.size()];
  for (int i=0; i < metricAggs.length; i++) {
    AggregatorFactory metricAgg=metricAggs[i];
    sortedMetricAggs[mergedMetrics.indexOf(metricAgg.getName())]=metricAgg;
  }
  for (int i=0; i < mergedMetrics.size(); i++) {
    if (!sortedMetricAggs[i].getName().equals(mergedMetrics.get(i))) {
      throw new IAE("Metric mismatch, index[%d] [%s] != [%s]",i,metricAggs[i].getName(),mergedMetrics.get(i));
    }
  }
  Function<ArrayList<Iterable<Rowboat>>,Iterable<Rowboat>> rowMergerFn=new Function<ArrayList<Iterable<Rowboat>>,Iterable<Rowboat>>(){
    @Override public Iterable<Rowboat> apply(    @Nullable ArrayList<Iterable<Rowboat>> boats){
      return CombiningIterable.create(new MergeIterable<>(Ordering.<Rowboat>natural().nullsFirst(),boats),Ordering.<Rowboat>natural().nullsFirst(),new IndexMerger.RowboatMergeFunction(sortedMetricAggs));
    }
  }
;
  return makeIndexFiles(adapters,outDir,progress,mergedDimensions,mergedMetrics,segmentMetadata,rowMergerFn,indexSpec);
}
