{
  MasterStats stats=new MasterStats();
  final ReplicationThrottler replicationManager=params.getReplicationManager();
  if (!params.hasDeletionWaitTimeElapsed()) {
    return stats;
  }
  if (clusterReplicants < expectedReplicants) {
    return stats;
  }
  Map<String,Integer> replicantsByType=params.getSegmentReplicantLookup().getClusterTiers(segment.getIdentifier());
  for (  Map.Entry<String,Integer> entry : replicantsByType.entrySet()) {
    String tier=entry.getKey();
    int actualNumReplicantsForType=entry.getValue();
    int expectedNumReplicantsForType=getReplicants(tier);
    MinMaxPriorityQueue<ServerHolder> serverQueue=params.getDruidCluster().get(tier);
    if (serverQueue == null) {
      log.makeAlert("No holders found for tier[%s]",entry.getKey()).emit();
      return stats;
    }
    List<ServerHolder> droppedServers=Lists.newArrayList();
    while (actualNumReplicantsForType > expectedNumReplicantsForType) {
      final ServerHolder holder=serverQueue.pollLast();
      if (holder == null) {
        log.warn("Wtf, holder was null?  I have no servers serving [%s]?",segment.getIdentifier());
        break;
      }
      if (holder.isServingSegment(segment)) {
        if (expectedNumReplicantsForType > 0) {
          if (!replicationManager.canDestroyReplicant(getTier())) {
            serverQueue.add(holder);
            break;
          }
          replicationManager.registerReplicantTermination(getTier(),segment.getIdentifier(),holder.getServer().getHost());
        }
        holder.getPeon().dropSegment(segment,new LoadPeonCallback(){
          @Override protected void execute(){
            replicationManager.unregisterReplicantTermination(getTier(),segment.getIdentifier(),holder.getServer().getHost());
          }
        }
);
        --actualNumReplicantsForType;
        stats.addToTieredStat("droppedCount",tier,1);
      }
      droppedServers.add(holder);
    }
    serverQueue.addAll(droppedServers);
  }
  return stats;
}
