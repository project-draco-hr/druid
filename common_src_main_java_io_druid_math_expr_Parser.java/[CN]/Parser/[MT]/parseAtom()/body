{
  Token t=lexer.peek();
switch (t.getType()) {
case Token.IDENTIFIER:
    lexer.consume();
  String id=t.getMatch();
if (func.containsKey(id)) {
  expect(Token.LPAREN);
  List<Expr> args=new ArrayList<>();
  t=lexer.peek();
  while (t.getType() != Token.RPAREN) {
    args.add(parseExpr(0));
    t=lexer.peek();
    if (t.getType() == Token.COMMA) {
      lexer.consume();
    }
  }
  expect(Token.RPAREN);
  return new FunctionAtom(id,args);
}
return new IdentifierAtom(t);
case Token.LONG:
lexer.consume();
return new LongValueAtom(Long.valueOf(t.getMatch()));
case Token.DOUBLE:
lexer.consume();
return new DoubleValueAtom(Double.valueOf(t.getMatch()));
case Token.MINUS:
lexer.consume();
return new UnaryMinusExprAtom(parseExpr(Token.UNARY_MINUS_PRECEDENCE));
case Token.NOT:
lexer.consume();
return new UnaryNotExprAtom(parseExpr(Token.UNARY_NOT_PRECEDENCE));
case Token.LPAREN:
lexer.consume();
Expr expression=parseExpr(0);
if (lexer.consume().getType() == Token.RPAREN) {
return new NestedExprAtom(expression);
}
default :
throw new RuntimeException("Invalid token found " + t + " in input "+ lexer);
}
}
