{
  final ListeningExecutorService queryExecutor=MoreExecutors.listeningDecorator(exec);
  if (config.get().isSingleThreaded()) {
    return new ConcatQueryRunner<>(Sequences.map(Sequences.simple(queryRunners),new Function<QueryRunner<Row>,QueryRunner<Row>>(){
      @Override public QueryRunner<Row> apply(      final QueryRunner<Row> input){
        return new QueryRunner<Row>(){
          @Override public Sequence<Row> run(          final Query<Row> query){
            final GroupByQuery queryParam=(GroupByQuery)query;
            final Pair<IncrementalIndex,Accumulator<IncrementalIndex,Row>> indexAccumulatorPair=GroupByQueryHelper.createIndexAccumulatorPair(queryParam,config.get());
            final Pair<List,Accumulator<List,Row>> bySegmentAccumulatorPair=GroupByQueryHelper.createBySegmentAccumulatorPair();
            final int priority=query.getContextPriority(0);
            final boolean bySegment=query.getContextBySegment(false);
            final ListenableFuture<Boolean> future=queryExecutor.submit(new AbstractPrioritizedCallable<Boolean>(priority){
              @Override public Boolean call() throws Exception {
                if (bySegment) {
                  input.run(queryParam).accumulate(bySegmentAccumulatorPair.lhs,bySegmentAccumulatorPair.rhs);
                  return true;
                }
                input.run(query).accumulate(indexAccumulatorPair.lhs,indexAccumulatorPair.rhs);
                return true;
              }
            }
);
            try {
              queryWatcher.registerQuery(query,future);
              final Number timeout=query.getContextValue("timeout",(Number)null);
              if (timeout == null) {
                future.get();
              }
 else {
                future.get(timeout.longValue(),TimeUnit.MILLISECONDS);
              }
            }
 catch (            InterruptedException e) {
              log.warn(e,"Query interrupted, cancelling pending results, query id [%s]",query.getId());
              future.cancel(true);
              throw new QueryInterruptedException("Query interrupted");
            }
catch (            CancellationException e) {
              throw new QueryInterruptedException("Query cancelled");
            }
catch (            TimeoutException e) {
              log.info("Query timeout, cancelling pending results for query id [%s]",query.getId());
              future.cancel(true);
              throw new QueryInterruptedException("Query timeout");
            }
catch (            ExecutionException e) {
              throw Throwables.propagate(e.getCause());
            }
            if (bySegment) {
              return Sequences.simple(bySegmentAccumulatorPair.lhs);
            }
            return Sequences.simple(indexAccumulatorPair.lhs.iterableWithPostAggregations(null));
          }
        }
;
      }
    }
));
  }
 else {
    return new GroupByParallelQueryRunner(queryExecutor,config,queryWatcher,queryRunners);
  }
}
