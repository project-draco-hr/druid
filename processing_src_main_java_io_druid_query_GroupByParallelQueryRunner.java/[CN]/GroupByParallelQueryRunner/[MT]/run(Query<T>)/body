{
  final GroupByQuery query=(GroupByQuery)queryParam;
  final Pair<IncrementalIndex,Accumulator<IncrementalIndex,T>> indexAccumulatorPair=GroupByQueryHelper.createIndexAccumulatorPair(query,configSupplier.get());
  final Pair<List,Accumulator<List,T>> bySegmentAccumulatorPair=GroupByQueryHelper.createBySegmentAccumulatorPair();
  final boolean bySegment=query.getContextBySegment(false);
  final int priority=query.getContextPriority(0);
  if (Iterables.isEmpty(queryables)) {
    log.warn("No queryables found.");
  }
  ListenableFuture<List<Boolean>> futures=Futures.allAsList(Lists.newArrayList(Iterables.transform(queryables,new Function<QueryRunner<T>,ListenableFuture<Boolean>>(){
    @Override public ListenableFuture<Boolean> apply(    final QueryRunner<T> input){
      return exec.submit(new AbstractPrioritizedCallable<Boolean>(priority){
        @Override public Boolean call() throws Exception {
          try {
            if (bySegment) {
              input.run(queryParam).accumulate(bySegmentAccumulatorPair.lhs,bySegmentAccumulatorPair.rhs);
              return true;
            }
            input.run(queryParam).accumulate(indexAccumulatorPair.lhs,indexAccumulatorPair.rhs);
            return true;
          }
 catch (          QueryInterruptedException e) {
            throw Throwables.propagate(e);
          }
catch (          Exception e) {
            log.error(e,"Exception with one of the sequences!");
            throw Throwables.propagate(e);
          }
        }
      }
);
    }
  }
)));
  try {
    queryWatcher.registerQuery(query,futures);
    final Number timeout=query.getContextValue("timeout",(Number)null);
    if (timeout == null) {
      futures.get();
    }
 else {
      futures.get(timeout.longValue(),TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    log.warn(e,"Query interrupted, cancelling pending results, query id [%s]",query.getId());
    futures.cancel(true);
    throw new QueryInterruptedException("Query interrupted");
  }
catch (  CancellationException e) {
    throw new QueryInterruptedException("Query cancelled");
  }
catch (  TimeoutException e) {
    log.info("Query timeout, cancelling pending results for query id [%s]",query.getId());
    futures.cancel(true);
    throw new QueryInterruptedException("Query timeout");
  }
catch (  ExecutionException e) {
    throw Throwables.propagate(e.getCause());
  }
  if (bySegment) {
    return Sequences.simple(bySegmentAccumulatorPair.lhs);
  }
  return Sequences.simple(Iterables.transform(indexAccumulatorPair.lhs.iterableWithPostAggregations(null),new Function<Row,T>(){
    @Override public T apply(    Row input){
      return (T)input;
    }
  }
));
}
