{
  supervisor=getSupervisor(2,1,true,"PT1H",null);
  addSomeEvents(1);
  DateTime now=DateTime.now();
  Task id1=createKafkaIndexTask("id1",DATASOURCE,"sequenceName-0",new KafkaPartitions("topic",ImmutableMap.of(0,0L,2,0L)),new KafkaPartitions("topic",ImmutableMap.of(0,Long.MAX_VALUE,2,Long.MAX_VALUE)),now);
  List<Task> existingTasks=ImmutableList.of(id1);
  Capture<Task> captured=Capture.newInstance();
  expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();
  expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();
  expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();
  expect(taskStorage.getActiveTasks()).andReturn(existingTasks).anyTimes();
  expect(taskStorage.getStatus("id1")).andReturn(Optional.of(TaskStatus.running("id1"))).anyTimes();
  expect(taskStorage.getTask("id1")).andReturn(Optional.of(id1)).anyTimes();
  expect(taskClient.getStatusAsync("id1")).andReturn(Futures.immediateFuture(KafkaIndexTask.Status.READING));
  expect(taskClient.getStartTimeAsync("id1")).andReturn(Futures.immediateFuture(now)).anyTimes();
  expect(taskQueue.add(capture(captured))).andReturn(true);
  expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(new KafkaDataSourceMetadata(null)).anyTimes();
  taskRunner.registerListener(anyObject(TaskRunnerListener.class),anyObject(Executor.class));
  replayAll();
  supervisor.start();
  supervisor.runInternal();
  verifyAll();
  Assert.assertEquals(now,((KafkaIndexTask)captured.getValue()).getIOConfig().getMinimumMessageTime().get());
  String runningTaskId=captured.getValue().getId();
  Capture<Task> aNewTaskCapture=Capture.newInstance();
  KafkaIndexTask iHaveFailed=(KafkaIndexTask)existingTasks.get(0);
  reset(taskStorage);
  reset(taskQueue);
  reset(taskClient);
  expect(taskStorage.getActiveTasks()).andReturn(ImmutableList.of(captured.getValue())).anyTimes();
  expect(taskStorage.getStatus(iHaveFailed.getId())).andReturn(Optional.of(TaskStatus.failure(iHaveFailed.getId())));
  expect(taskStorage.getStatus(runningTaskId)).andReturn(Optional.of(TaskStatus.running(runningTaskId))).anyTimes();
  expect(taskStorage.getTask(iHaveFailed.getId())).andReturn(Optional.of((Task)iHaveFailed)).anyTimes();
  expect(taskStorage.getTask(runningTaskId)).andReturn(Optional.of(captured.getValue())).anyTimes();
  expect(taskClient.getStatusAsync(runningTaskId)).andReturn(Futures.immediateFuture(KafkaIndexTask.Status.READING));
  expect(taskClient.getStartTimeAsync(runningTaskId)).andReturn(Futures.immediateFuture(now)).anyTimes();
  expect(taskQueue.add(capture(aNewTaskCapture))).andReturn(true);
  replay(taskStorage);
  replay(taskQueue);
  replay(taskClient);
  supervisor.runInternal();
  verifyAll();
  Assert.assertNotEquals(iHaveFailed.getId(),aNewTaskCapture.getValue().getId());
  Assert.assertEquals(iHaveFailed.getIOConfig().getBaseSequenceName(),((KafkaIndexTask)aNewTaskCapture.getValue()).getIOConfig().getBaseSequenceName());
  Assert.assertEquals(now,((KafkaIndexTask)aNewTaskCapture.getValue()).getIOConfig().getMinimumMessageTime().get());
}
