{
  Interval actualIntervalTmp=interval;
  Interval dataInterval=getInterval();
  if (!actualIntervalTmp.overlaps(dataInterval)) {
    return ImmutableList.of();
  }
  if (actualIntervalTmp.getStart().isBefore(dataInterval.getStart())) {
    actualIntervalTmp=actualIntervalTmp.withStart(dataInterval.getStart());
  }
  if (actualIntervalTmp.getEnd().isAfter(dataInterval.getEnd())) {
    actualIntervalTmp=actualIntervalTmp.withEnd(dataInterval.getEnd());
  }
  final Interval actualInterval=actualIntervalTmp;
  return new Iterable<Cursor>(){
    @Override public Iterator<Cursor> iterator(){
      return FunctionalIterator.create(gran.iterable(actualInterval.getStartMillis(),actualInterval.getEndMillis()).iterator()).transform(new Function<Long,Cursor>(){
        EntryHolder currEntry=new EntryHolder();
        private final ValueMatcher filterMatcher;
{
          filterMatcher=makeFilterMatcher(filter,currEntry);
        }
        @Override public Cursor apply(        @Nullable final Long input){
          final long timeStart=Math.max(input,actualInterval.getStartMillis());
          return new Cursor(){
            private Iterator<Map.Entry<IncrementalIndex.TimeAndDims,Aggregator[]>> baseIter;
            private ConcurrentNavigableMap<IncrementalIndex.TimeAndDims,Aggregator[]> cursorMap;
            final DateTime time;
            int numAdvanced=-1;
            boolean done;
{
              cursorMap=index.getSubMap(new IncrementalIndex.TimeAndDims(timeStart,new String[][]{}),new IncrementalIndex.TimeAndDims(Math.min(actualInterval.getEndMillis(),gran.next(timeStart)),new String[][]{}));
              time=gran.toDateTime(input);
              reset();
            }
            @Override public DateTime getTime(){
              return time;
            }
            @Override public void advance(){
              if (!baseIter.hasNext()) {
                done=true;
                return;
              }
              while (baseIter.hasNext()) {
                currEntry.set(baseIter.next());
                if (filterMatcher.matches()) {
                  return;
                }
              }
              if (!filterMatcher.matches()) {
                done=true;
              }
            }
            @Override public boolean isDone(){
              return done;
            }
            @Override public void reset(){
              baseIter=cursorMap.entrySet().iterator();
              if (numAdvanced == -1) {
                numAdvanced=0;
                while (baseIter.hasNext()) {
                  currEntry.set(baseIter.next());
                  if (filterMatcher.matches()) {
                    return;
                  }
                  numAdvanced++;
                }
              }
 else {
                Iterators.skip(baseIter,numAdvanced);
                if (baseIter.hasNext()) {
                  currEntry.set(baseIter.next());
                }
              }
              done=cursorMap.size() == 0 || !baseIter.hasNext();
            }
            @Override public DimensionSelector makeDimensionSelector(            String dimension){
              final String dimensionName=dimension.toLowerCase();
              final IncrementalIndex.DimDim dimValLookup=index.getDimension(dimensionName);
              if (dimValLookup == null) {
                return null;
              }
              final int maxId=dimValLookup.size();
              final int dimIndex=index.getDimensionIndex(dimensionName);
              return new DimensionSelector(){
                @Override public IndexedInts getRow(){
                  final ArrayList<Integer> vals=Lists.newArrayList();
                  if (dimIndex < currEntry.getKey().getDims().length) {
                    final String[] dimVals=currEntry.getKey().getDims()[dimIndex];
                    if (dimVals != null) {
                      for (                      String dimVal : dimVals) {
                        int id=dimValLookup.getId(dimVal);
                        if (id < maxId) {
                          vals.add(id);
                        }
                      }
                    }
                  }
                  return new IndexedInts(){
                    @Override public int size(){
                      return vals.size();
                    }
                    @Override public int get(                    int index){
                      return vals.get(index);
                    }
                    @Override public Iterator<Integer> iterator(){
                      return vals.iterator();
                    }
                  }
;
                }
                @Override public int getValueCardinality(){
                  return dimValLookup.size();
                }
                @Override public String lookupName(                int id){
                  return dimValLookup.getValue(id);
                }
                @Override public int lookupId(                String name){
                  return dimValLookup.getId(name);
                }
              }
;
            }
            @Override public FloatMetricSelector makeFloatMetricSelector(            String metric){
              final String metricName=metric.toLowerCase();
              final Integer metricIndexInt=index.getMetricIndex(metricName);
              if (metricIndexInt == null) {
                return new FloatMetricSelector(){
                  @Override public float get(){
                    return 0.0f;
                  }
                }
;
              }
              final int metricIndex=metricIndexInt;
              return new FloatMetricSelector(){
                @Override public float get(){
                  return currEntry.getValue()[metricIndex].getFloat();
                }
              }
;
            }
            @Override public ComplexMetricSelector makeComplexMetricSelector(            String metric){
              final String metricName=metric.toLowerCase();
              final Integer metricIndexInt=index.getMetricIndex(metricName);
              if (metricIndexInt == null) {
                return null;
              }
              final int metricIndex=metricIndexInt;
              final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(index.getMetricType(metricName));
              return new ComplexMetricSelector(){
                @Override public Class classOfObject(){
                  return serde.getObjectStrategy().getClazz();
                }
                @Override public Object get(){
                  return currEntry.getValue()[metricIndex].get();
                }
              }
;
            }
          }
;
        }
      }
);
    }
  }
;
}
