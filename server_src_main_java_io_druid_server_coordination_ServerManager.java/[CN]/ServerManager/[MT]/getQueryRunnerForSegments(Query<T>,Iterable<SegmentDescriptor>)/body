{
  final QueryRunnerFactory<T,Query<T>> factory=conglomerate.findFactory(query);
  if (factory == null) {
    log.makeAlert("Unknown query type, [%s]",query.getClass()).addData("dataSource",query.getDataSource()).emit();
    return new NoopQueryRunner<T>();
  }
  final QueryToolChest<T,Query<T>> toolChest=factory.getToolchest();
  String dataSourceName;
  try {
    dataSourceName=((TableDataSource)query.getDataSource()).getName();
  }
 catch (  ClassCastException e) {
    throw new UnsupportedOperationException("Subqueries are only supported in the broker");
  }
  final VersionedIntervalTimeline<String,ReferenceCountingSegment> timeline=dataSources.get(dataSourceName);
  if (timeline == null) {
    return new NoopQueryRunner<T>();
  }
  FunctionalIterable<QueryRunner<T>> adapters=FunctionalIterable.create(specs).transformCat(new Function<SegmentDescriptor,Iterable<QueryRunner<T>>>(){
    @Override @SuppressWarnings("unchecked") public Iterable<QueryRunner<T>> apply(    SegmentDescriptor input){
      final PartitionHolder<ReferenceCountingSegment> entry=timeline.findEntry(input.getInterval(),input.getVersion());
      if (entry == null) {
        return null;
      }
      final PartitionChunk<ReferenceCountingSegment> chunk=entry.getChunk(input.getPartitionNumber());
      if (chunk == null) {
        return null;
      }
      final ReferenceCountingSegment adapter=chunk.getObject();
      return Arrays.asList(buildAndDecorateQueryRunner(factory,toolChest,adapter,new SpecificSegmentSpec(input)));
    }
  }
).filter(Predicates.<QueryRunner<T>>notNull());
  return new FinalizeResultsQueryRunner<T>(toolChest.mergeResults(factory.mergeRunners(exec,adapters)),toolChest);
}
