{
  return new CacheStrategy<Row,Object,GroupByQuery>(){
    private final List<AggregatorFactory> aggs=query.getAggregatorSpecs();
    @Override public byte[] computeCacheKey(    GroupByQuery query){
      final DimFilter dimFilter=query.getDimFilter();
      final byte[] filterBytes=dimFilter == null ? new byte[]{} : dimFilter.getCacheKey();
      final byte[] aggregatorBytes=QueryCacheHelper.computeAggregatorBytes(query.getAggregatorSpecs());
      final byte[] granularityBytes=query.getGranularity().cacheKey();
      final byte[][] dimensionsBytes=new byte[query.getDimensions().size()][];
      int dimensionsBytesSize=0;
      int index=0;
      for (      DimensionSpec dimension : query.getDimensions()) {
        dimensionsBytes[index]=dimension.getCacheKey();
        dimensionsBytesSize+=dimensionsBytes[index].length;
        ++index;
      }
      final byte[] havingBytes=query.getHavingSpec() == null ? new byte[]{} : query.getHavingSpec().getCacheKey();
      final byte[] limitBytes=query.getLimitSpec().getCacheKey();
      ByteBuffer buffer=ByteBuffer.allocate(1 + granularityBytes.length + filterBytes.length+ aggregatorBytes.length+ dimensionsBytesSize+ havingBytes.length+ limitBytes.length).put(GROUPBY_QUERY).put(granularityBytes).put(filterBytes).put(aggregatorBytes);
      for (      byte[] dimensionsByte : dimensionsBytes) {
        buffer.put(dimensionsByte);
      }
      return buffer.put(havingBytes).put(limitBytes).array();
    }
    @Override public TypeReference<Object> getCacheObjectClazz(){
      return OBJECT_TYPE_REFERENCE;
    }
    @Override public Function<Row,Object> prepareForCache(){
      return new Function<Row,Object>(){
        @Override public Object apply(        Row input){
          if (input instanceof MapBasedRow) {
            final MapBasedRow row=(MapBasedRow)input;
            final List<Object> retVal=Lists.newArrayListWithCapacity(2);
            retVal.add(row.getTimestamp().getMillis());
            retVal.add(row.getEvent());
            return retVal;
          }
          throw new ISE("Don't know how to cache input rows of type[%s]",input.getClass());
        }
      }
;
    }
    @Override public Function<Object,Row> pullFromCache(){
      return new Function<Object,Row>(){
        private final QueryGranularity granularity=query.getGranularity();
        @Override public Row apply(        Object input){
          Iterator<Object> results=((List<Object>)input).iterator();
          DateTime timestamp=granularity.toDateTime(((Number)results.next()).longValue());
          Iterator<AggregatorFactory> aggsIter=aggs.iterator();
          Map<String,Object> event=jsonMapper.convertValue(results.next(),new TypeReference<Map<String,Object>>(){
          }
);
          while (aggsIter.hasNext()) {
            final AggregatorFactory factory=aggsIter.next();
            Object agg=event.remove(factory.getName());
            if (agg != null) {
              event.put(factory.getName(),factory.deserialize(agg));
            }
          }
          return new MapBasedRow(timestamp,event);
        }
      }
;
    }
    @Override public Sequence<Row> mergeSequences(    Sequence<Sequence<Row>> seqOfSequences){
      return new MergeSequence<>(Ordering.<Row>natural().nullsFirst(),seqOfSequences);
    }
  }
;
}
