{
  final String section=String.format("make %s",dimension);
  progress.startSection(section);
  final ColumnDescriptor.Builder dimBuilder=ColumnDescriptor.builder();
  dimBuilder.setValueType(ValueType.STRING);
  final List<ByteBuffer> outParts=Lists.newArrayList();
  ByteArrayOutputStream nameBAOS=new ByteArrayOutputStream();
  serializerUtils.writeString(nameBAOS,dimension);
  outParts.add(ByteBuffer.wrap(nameBAOS.toByteArray()));
  boolean hasMultipleValues=columnCapabilities.get(dimension).hasMultipleValues();
  dimBuilder.setHasMultipleValues(hasMultipleValues);
  List<Integer> singleValCol;
  final VSizeIndexed multiValCol;
  ColumnDictionaryEntryStore adder=hasMultipleValues ? new MultiValColumnDictionaryEntryStore() : new SingleValColumnDictionaryEntryStore();
  final BitmapFactory bitmapFactory=bitmapSerdeFactory.getBitmapFactory();
  MutableBitmap nullSet=null;
  int rowCount=0;
  for (  Rowboat theRow : theRows) {
    if (dimIndex > theRow.getDims().length) {
      if (nullSet == null) {
        nullSet=bitmapFactory.makeEmptyMutableBitmap();
      }
      nullSet.add(rowCount);
      adder.add(null);
    }
 else {
      int[] dimVals=theRow.getDims()[dimIndex];
      if (dimVals == null || dimVals.length == 0) {
        if (nullSet == null) {
          nullSet=bitmapFactory.makeEmptyMutableBitmap();
        }
        nullSet.add(rowCount);
      }
      adder.add(dimVals);
    }
    rowCount++;
  }
  final Iterable<String> dimensionValues=dimensionValuesLookup.get(dimension);
  GenericIndexed<String> dictionary=GenericIndexed.fromIterable(dimensionValues,GenericIndexed.STRING_STRATEGY);
  boolean bumpDictionary=false;
  if (hasMultipleValues) {
    final List<List<Integer>> vals=((MultiValColumnDictionaryEntryStore)adder).get();
    if (nullSet != null) {
      log.info("Dimension[%s] has null rows.",dimension);
      if (Iterables.getFirst(dimensionValues,"") != null) {
        bumpDictionary=true;
        log.info("Dimension[%s] has no null value in the dictionary, expanding...",dimension);
        dictionary=GenericIndexed.fromIterable(Iterables.concat(Collections.<String>singleton(null),dimensionValues),GenericIndexed.STRING_STRATEGY);
        final int dictionarySize=dictionary.size();
        singleValCol=null;
        multiValCol=VSizeIndexed.fromIterable(Iterables.transform(vals,new Function<List<Integer>,VSizeIndexedInts>(){
          @Override public VSizeIndexedInts apply(          final List<Integer> input){
            if (input == null) {
              return VSizeIndexedInts.fromList(ImmutableList.<Integer>of(0),dictionarySize);
            }
 else {
              return VSizeIndexedInts.fromList(new NullsAtZeroConvertingIntList(input,false),dictionarySize);
            }
          }
        }
));
      }
 else {
        final int dictionarySize=dictionary.size();
        singleValCol=null;
        multiValCol=VSizeIndexed.fromIterable(Iterables.transform(vals,new Function<List<Integer>,VSizeIndexedInts>(){
          @Override public VSizeIndexedInts apply(          List<Integer> input){
            if (input == null) {
              return VSizeIndexedInts.fromList(ImmutableList.<Integer>of(0),dictionarySize);
            }
 else {
              return VSizeIndexedInts.fromList(input,dictionarySize);
            }
          }
        }
));
      }
    }
 else {
      final int dictionarySize=dictionary.size();
      singleValCol=null;
      multiValCol=VSizeIndexed.fromIterable(Iterables.transform(vals,new Function<List<Integer>,VSizeIndexedInts>(){
        @Override public VSizeIndexedInts apply(        List<Integer> input){
          return VSizeIndexedInts.fromList(input,dictionarySize);
        }
      }
));
    }
  }
 else {
    final List<Integer> vals=((SingleValColumnDictionaryEntryStore)adder).get();
    if (nullSet != null) {
      log.info("Dimension[%s] has null rows.",dimension);
      if (Iterables.getFirst(dimensionValues,"") != null) {
        bumpDictionary=true;
        log.info("Dimension[%s] has no null value in the dictionary, expanding...",dimension);
        final List<String> nullList=Lists.newArrayList();
        nullList.add(null);
        dictionary=GenericIndexed.fromIterable(Iterables.concat(nullList,dimensionValues),GenericIndexed.STRING_STRATEGY);
        multiValCol=null;
        singleValCol=new NullsAtZeroConvertingIntList(vals,false);
      }
 else {
        multiValCol=null;
        singleValCol=new NullsAtZeroConvertingIntList(vals,true);
      }
    }
 else {
      multiValCol=null;
      singleValCol=new AbstractList<Integer>(){
        @Override public Integer get(        int index){
          return vals.get(index);
        }
        @Override public int size(){
          return vals.size();
        }
      }
;
    }
  }
  List<MutableBitmap> mutableBitmaps=Lists.newArrayList();
  for (  String dimVal : dimensionValues) {
    List<Iterable<Integer>> convertedInverteds=Lists.newArrayListWithCapacity(adapters.size());
    for (int j=0; j < adapters.size(); ++j) {
      convertedInverteds.add(new ConvertingIndexedInts(adapters.get(j).getBitmapIndex(dimension,dimVal),rowNumConversions.get(j)));
    }
    MutableBitmap bitset=bitmapSerdeFactory.getBitmapFactory().makeEmptyMutableBitmap();
    for (    Integer row : CombiningIterable.createSplatted(convertedInverteds,Ordering.<Integer>natural().nullsFirst())) {
      if (row != INVALID_ROW) {
        bitset.add(row);
      }
    }
    mutableBitmaps.add(bitset);
  }
  GenericIndexed<ImmutableBitmap> bitmaps;
  if (nullSet != null) {
    final ImmutableBitmap theNullSet=bitmapFactory.makeImmutableBitmap(nullSet);
    if (bumpDictionary) {
      bitmaps=GenericIndexed.fromIterable(Iterables.concat(Arrays.asList(theNullSet),Iterables.transform(mutableBitmaps,new Function<MutableBitmap,ImmutableBitmap>(){
        @Override public ImmutableBitmap apply(        MutableBitmap input){
          return bitmapFactory.makeImmutableBitmap(input);
        }
      }
)),bitmapSerdeFactory.getObjectStrategy());
    }
 else {
      Iterable<ImmutableBitmap> immutableBitmaps=Iterables.transform(mutableBitmaps,new Function<MutableBitmap,ImmutableBitmap>(){
        @Override public ImmutableBitmap apply(        MutableBitmap input){
          return bitmapFactory.makeImmutableBitmap(input);
        }
      }
);
      bitmaps=GenericIndexed.fromIterable(Iterables.concat(Arrays.asList(theNullSet.union(Iterables.getFirst(immutableBitmaps,null))),Iterables.skip(immutableBitmaps,1)),bitmapSerdeFactory.getObjectStrategy());
    }
  }
 else {
    bitmaps=GenericIndexed.fromIterable(Iterables.transform(mutableBitmaps,new Function<MutableBitmap,ImmutableBitmap>(){
      @Override public ImmutableBitmap apply(      MutableBitmap input){
        return bitmapFactory.makeImmutableBitmap(input);
      }
    }
),bitmapSerdeFactory.getObjectStrategy());
  }
  ImmutableRTree spatialIndex=null;
  boolean hasSpatialIndexes=columnCapabilities.get(dimension).hasSpatialIndexes();
  RTree tree=null;
  if (hasSpatialIndexes) {
    tree=new RTree(2,new LinearGutmanSplitStrategy(0,50,bitmapSerdeFactory.getBitmapFactory()),bitmapSerdeFactory.getBitmapFactory());
  }
  int dimValIndex=0;
  for (  String dimVal : dimensionValuesLookup.get(dimension)) {
    if (hasSpatialIndexes) {
      if (dimVal != null && !dimVal.isEmpty()) {
        List<String> stringCoords=Lists.newArrayList(SPLITTER.split(dimVal));
        float[] coords=new float[stringCoords.size()];
        for (int j=0; j < coords.length; j++) {
          coords[j]=Float.valueOf(stringCoords.get(j));
        }
        tree.insert(coords,mutableBitmaps.get(dimValIndex));
      }
      dimValIndex++;
    }
  }
  if (hasSpatialIndexes) {
    spatialIndex=ImmutableRTree.newImmutableFromMutable(tree);
  }
  log.info("Completed dimension[%s] with cardinality[%,d]. Starting write.",dimension,dictionary.size());
  final DictionaryEncodedColumnPartSerde.Builder dimPartBuilder=DictionaryEncodedColumnPartSerde.builder().withDictionary(dictionary).withBitmapSerdeFactory(bitmapSerdeFactory).withBitmaps(bitmaps).withSpatialIndex(spatialIndex).withByteOrder(IndexIO.BYTE_ORDER);
  if (singleValCol != null) {
    if (compressionStrategy != null) {
      dimPartBuilder.withSingleValuedColumn(CompressedVSizeIntsIndexedSupplier.fromList(singleValCol,dictionary.size(),CompressedVSizeIntsIndexedSupplier.maxIntsInBufferForValue(dictionary.size()),IndexIO.BYTE_ORDER,compressionStrategy));
    }
 else {
      dimPartBuilder.withSingleValuedColumn(VSizeIndexedInts.fromList(singleValCol,dictionary.size()));
    }
  }
 else   if (compressionStrategy != null) {
    dimPartBuilder.withMultiValuedColumn(CompressedVSizeIndexedSupplier.fromIterable(multiValCol,dictionary.size(),IndexIO.BYTE_ORDER,compressionStrategy));
  }
 else {
    dimPartBuilder.withMultiValuedColumn(multiValCol);
  }
  writeColumn(v9Smoosher,dimPartBuilder.build(),dimBuilder,dimension);
  progress.stopSection(section);
}
