{
  final String section="setup dimension conversions";
  progress.startSection(section);
  for (  IndexableAdapter adapter : adapters) {
    dimConversions.add(Maps.<String,IntBuffer>newHashMap());
  }
  int dimIndex=0;
  for (  String dimension : mergedDimensions) {
    dimIndexes.put(dimension,dimIndex++);
    final List<Indexed<String>> dimValueLookups=Lists.newArrayListWithCapacity(adapters.size());
    final DimValueConverter[] converters=new DimValueConverter[adapters.size()];
    for (int i=0; i < adapters.size(); i++) {
      Indexed<String> dimValues=adapters.get(i).getDimValueLookup(dimension);
      if (dimValues != null) {
        dimValueLookups.add(dimValues);
        converters[i]=new DimValueConverter(dimValues);
      }
    }
    final Iterable<String> dimensionValues=CombiningIterable.createSplatted(Iterables.transform(dimValueLookups,new Function<Indexed<String>,Iterable<String>>(){
      @Override public Iterable<String> apply(      Indexed<String> indexed){
        return Iterables.transform(indexed,new Function<String,String>(){
          @Override public String apply(          @Nullable String input){
            return (input == null) ? "" : input;
          }
        }
);
      }
    }
),Ordering.<String>natural());
    int cardinality=0;
    for (    String value : dimensionValues) {
      for (int i=0; i < adapters.size(); i++) {
        DimValueConverter converter=converters[i];
        if (converter != null) {
          converter.convert(value,cardinality);
        }
      }
      ++cardinality;
    }
    if (cardinality == 0) {
      log.info("Skipping [%s], it is empty!",dimension);
      skippedDimensions.add(dimension);
      continue;
    }
    dimensionValuesLookup.put(dimension,dimensionValues);
    for (int i=0; i < adapters.size(); ++i) {
      DimValueConverter converter=converters[i];
      if (converter != null) {
        dimConversions.get(i).put(dimension,converters[i].getConversionBuffer());
      }
    }
  }
  progress.stopSection(section);
}
