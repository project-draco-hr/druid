{
  final String section="building index.drd";
  progress.startSection(section);
  final Set<String> finalColumns=Sets.newTreeSet();
  finalColumns.addAll(mergedDimensions);
  finalColumns.addAll(mergedMetrics);
  finalColumns.removeAll(skippedDimensions);
  final Iterable<String> finalDimensions=Iterables.filter(mergedDimensions,new Predicate<String>(){
    @Override public boolean apply(    String input){
      return !skippedDimensions.contains(input);
    }
  }
);
  GenericIndexed<String> cols=GenericIndexed.fromIterable(finalColumns,GenericIndexed.stringStrategy);
  GenericIndexed<String> dims=GenericIndexed.fromIterable(finalDimensions,GenericIndexed.stringStrategy);
  final String bitmapSerdeFactoryType=mapper.writeValueAsString(indexSpec.getBitmapSerdeFactory());
  final long numBytes=cols.getSerializedSize() + dims.getSerializedSize() + 16+ serializerUtils.getSerializedStringByteSize(bitmapSerdeFactoryType);
  final SmooshedWriter writer=v9Smoosher.addWithSmooshedWriter("index.drd",numBytes);
  cols.writeToChannel(writer);
  dims.writeToChannel(writer);
  DateTime minTime=new DateTime(JodaUtils.MAX_INSTANT);
  DateTime maxTime=new DateTime(JodaUtils.MIN_INSTANT);
  for (  IndexableAdapter index : adapters) {
    minTime=JodaUtils.minDateTime(minTime,index.getDataInterval().getStart());
    maxTime=JodaUtils.maxDateTime(maxTime,index.getDataInterval().getEnd());
  }
  final Interval dataInterval=new Interval(minTime,maxTime);
  serializerUtils.writeLong(writer,dataInterval.getStartMillis());
  serializerUtils.writeLong(writer,dataInterval.getEndMillis());
  serializerUtils.writeString(writer,bitmapSerdeFactoryType);
  writer.close();
  IndexIO.checkFileSize(new File(outDir,"index.drd"));
  progress.stopSection(section);
}
