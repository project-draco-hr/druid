{
  return new Iterable<Rowboat>(){
    @Override public Iterator<Rowboat> iterator(){
      return new Iterator<Rowboat>(){
        final IndexedLongs timestamps=index.getReadOnlyTimestamps();
        final MetricHolder[] metrics;
        final IndexedFloats[] floatMetrics;
        final Map<String,Indexed<? extends IndexedInts>> dimensions;
        final int numMetrics=index.getAvailableMetrics().size();
        int currRow=0;
        boolean done=false;
{
          dimensions=Maps.newLinkedHashMap();
          for (          String dim : index.getAvailableDimensions()) {
            dimensions.put(dim,index.getDimColumn(dim));
          }
          final Indexed<String> availableMetrics=index.getAvailableMetrics();
          metrics=new MetricHolder[availableMetrics.size()];
          floatMetrics=new IndexedFloats[availableMetrics.size()];
          for (int i=0; i < metrics.length; ++i) {
            metrics[i]=index.getMetricHolder(availableMetrics.get(i));
            if (metrics[i].getType() == MetricHolder.MetricType.FLOAT) {
              floatMetrics[i]=metrics[i].getFloatType();
            }
          }
        }
        @Override public boolean hasNext(){
          final boolean hasNext=currRow < numRows;
          if (!hasNext && !done) {
            Closeables.closeQuietly(timestamps);
            for (            IndexedFloats floatMetric : floatMetrics) {
              Closeables.closeQuietly(floatMetric);
            }
            done=true;
          }
          return hasNext;
        }
        @Override public Rowboat next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          int[][] dims=new int[dimensions.size()][];
          int dimIndex=0;
          for (          String dim : dimensions.keySet()) {
            IndexedInts dimVals=dimensions.get(dim).get(currRow);
            int[] theVals=new int[dimVals.size()];
            for (int j=0; j < theVals.length; ++j) {
              theVals[j]=dimVals.get(j);
            }
            dims[dimIndex++]=theVals;
          }
          Object[] metricArray=new Object[numMetrics];
          for (int i=0; i < metricArray.length; ++i) {
switch (metrics[i].getType()) {
case FLOAT:
              metricArray[i]=floatMetrics[i].get(currRow);
            break;
case COMPLEX:
          metricArray[i]=metrics[i].getComplexType().get(currRow);
      }
    }
    final Rowboat retVal=new Rowboat(timestamps.get(currRow),dims,metricArray,currRow);
    ++currRow;
    return retVal;
  }
  @Override public void remove(){
    throw new UnsupportedOperationException();
  }
}
;
}
}
;
}
