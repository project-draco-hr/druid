{
  final Supplier<GroupByQueryConfig> groupByQueryConfigSupplier=Suppliers.ofInstance(new GroupByQueryConfig());
  return new CachingClusteredClient(new MapQueryToolChestWarehouse(ImmutableMap.<Class<? extends Query>,QueryToolChest>builder().put(TimeseriesQuery.class,new TimeseriesQueryQueryToolChest(new QueryConfig())).put(TopNQuery.class,new TopNQueryQueryToolChest(new TopNQueryConfig())).put(SearchQuery.class,new SearchQueryQueryToolChest(new SearchQueryConfig())).put(SelectQuery.class,new SelectQueryQueryToolChest(new SelectQueryConfig(),jsonMapper)).put(GroupByQuery.class,new GroupByQueryQueryToolChest(groupByQueryConfigSupplier,jsonMapper,new GroupByQueryEngine(groupByQueryConfigSupplier,new StupidPool<>(new Supplier<ByteBuffer>(){
    @Override public ByteBuffer get(){
      return ByteBuffer.allocate(1024 * 1024);
    }
  }
)))).put(TimeBoundaryQuery.class,new TimeBoundaryQueryQueryToolChest()).build()),new TimelineServerView(){
    @Override public void registerSegmentCallback(    Executor exec,    SegmentCallback callback){
    }
    @Override public VersionedIntervalTimeline<String,ServerSelector> getTimeline(    DataSource dataSource){
      return timeline;
    }
    @Override public <T>QueryRunner<T> getQueryRunner(    DruidServer server){
      return serverView.getQueryRunner(server);
    }
    @Override public void registerServerCallback(    Executor exec,    ServerCallback callback){
    }
  }
,cache,jsonMapper,new CacheConfig(){
    @Override public boolean isQueryCacheable(    Query query){
      return true;
    }
  }
);
}
