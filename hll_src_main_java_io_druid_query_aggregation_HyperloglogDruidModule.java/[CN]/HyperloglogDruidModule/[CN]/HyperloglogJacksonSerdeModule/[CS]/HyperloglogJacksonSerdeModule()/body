{
  super("Hyperloglog deserializers");
  addDeserializer(TIntByteHashMap.class,new JsonDeserializer<TIntByteHashMap>(){
    @Override public TIntByteHashMap deserialize(    JsonParser jp,    DeserializationContext ctxt) throws IOException {
      byte[] ibmapByte=Base64.decodeBase64(jp.getText());
      ByteBuffer buffer=ByteBuffer.wrap(ibmapByte);
      int keylength=buffer.getInt();
      int valuelength=buffer.getInt();
      if (keylength == 0) {
        return (new TIntByteHashMap());
      }
      int[] keys=new int[keylength];
      byte[] values=new byte[valuelength];
      for (int i=0; i < keylength; i++) {
        keys[i]=buffer.getInt();
      }
      buffer.get(values);
      return (new TIntByteHashMap(keys,values));
    }
  }
);
  addSerializer(TIntByteHashMap.class,new JsonSerializer<TIntByteHashMap>(){
    @Override public void serialize(    TIntByteHashMap ibmap,    JsonGenerator jsonGenerator,    SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
      int[] indexesResult=ibmap.keys();
      byte[] valueResult=ibmap.values();
      ByteBuffer buffer=ByteBuffer.allocate(4 * indexesResult.length + valueResult.length + 8);
      byte[] result=new byte[4 * indexesResult.length + valueResult.length + 8];
      buffer.putInt((int)indexesResult.length);
      buffer.putInt((int)valueResult.length);
      for (int i=0; i < indexesResult.length; i++) {
        buffer.putInt(indexesResult[i]);
      }
      buffer.put(valueResult);
      buffer.flip();
      buffer.get(result);
      String str=Base64.encodeBase64String(result);
      jsonGenerator.writeString(str);
    }
  }
);
}
