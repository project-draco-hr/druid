{
  Preconditions.checkArgument(chunkFactor <= MAX_LONGS_IN_BUFFER,"Chunks must be <= 64k bytes. chunkFactor was[%s]",chunkFactor);
  return new CompressedLongsIndexedSupplier(list.size(),chunkFactor,GenericIndexed.fromIterable(new Iterable<ResourceHolder<LongBuffer>>(){
    @Override public Iterator<ResourceHolder<LongBuffer>> iterator(){
      return new Iterator<ResourceHolder<LongBuffer>>(){
        int position=0;
        @Override public boolean hasNext(){
          return position < list.size();
        }
        @Override public ResourceHolder<LongBuffer> next(){
          LongBuffer retVal=LongBuffer.allocate(chunkFactor);
          if (chunkFactor > list.size() - position) {
            retVal.limit(list.size() - position);
          }
          final List<Long> longs=list.subList(position,position + retVal.remaining());
          for (          long value : longs) {
            retVal.put(value);
          }
          retVal.rewind();
          position+=retVal.remaining();
          return StupidResourceHolder.create(retVal);
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
,CompressedLongBufferObjectStrategy.getBufferForOrder(byteOrder,compression,chunkFactor)),compression);
}
