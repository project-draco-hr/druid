{
  Preconditions.checkNotNull(task,"task");
  Preconditions.checkNotNull(taskRunnerWorkItem,"taskRunnerWorkItem");
  Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()),"task id != workItem id");
  if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {
    log.info("Task[%s] already running.",task.getId());
    return true;
  }
 else {
    final Optional<ImmutableZkWorker> immutableZkWorker=strategy.findWorkerForTask(ImmutableMap.copyOf(Maps.transformEntries(zkWorkers,new Maps.EntryTransformer<String,ZkWorker,ImmutableZkWorker>(){
      @Override public ImmutableZkWorker transformEntry(      String key,      ZkWorker value){
        return value.toImmutable();
      }
    }
)),task);
    if (immutableZkWorker.isPresent()) {
      final ZkWorker zkWorker=zkWorkers.get(immutableZkWorker.get().getWorker().getHost());
      announceTask(task,zkWorker,taskRunnerWorkItem);
      return true;
    }
 else {
      log.debug("Worker nodes %s do not have capacity to run any more tasks!",zkWorkers.values());
      return false;
    }
  }
}
