{
  giant.lock();
  try {
    final String dataSource=task.getDataSource();
    final Interval interval=task.getInterval();
    final List<TaskGroup> foundLocks=findTaskGroupsForInterval(dataSource,interval);
    final TaskGroup taskGroupToUse;
    if (foundLocks.size() > 1) {
      return Optional.absent();
    }
 else     if (foundLocks.size() == 1) {
      final TaskGroup foundLock=Iterables.getOnlyElement(foundLocks);
      if (foundLock.getInterval().contains(interval) && foundLock.getGroupId().equals(task.getGroupId())) {
        taskGroupToUse=foundLock;
      }
 else {
        return Optional.absent();
      }
    }
 else {
      if (!running.containsKey(dataSource)) {
        running.put(dataSource,new TreeMap<Interval,TaskGroup>(Comparators.intervalsByStartThenEnd()));
      }
      final String version;
      if (preferredVersion.isPresent()) {
        version=preferredVersion.get();
      }
 else {
        version=new DateTime().toString();
      }
      taskGroupToUse=new TaskGroup(task.getGroupId(),dataSource,interval,version);
      running.get(dataSource).put(interval,taskGroupToUse);
      log.info("Created new TaskGroup[%s]",taskGroupToUse);
    }
    if (taskGroupToUse.add(task)) {
      log.info("Added task[%s] to TaskGroup[%s]",task.getId(),taskGroupToUse.getGroupId());
    }
 else {
      log.info("Task[%s] already present in TaskGroup[%s]",task.getId(),taskGroupToUse.getGroupId());
    }
    return Optional.of(taskGroupToUse.getVersion());
  }
  finally {
    giant.unlock();
  }
}
