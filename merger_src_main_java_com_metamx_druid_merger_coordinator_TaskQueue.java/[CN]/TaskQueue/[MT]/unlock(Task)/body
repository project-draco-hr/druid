{
  giant.lock();
  try {
    final String dataSource=task.getDataSource();
    final Interval interval=task.getInterval();
    final List<TaskGroup> maybeTaskGroup=Lists.newArrayList(FunctionalIterable.create(findLocks(dataSource,interval)).filter(new Predicate<TaskGroup>(){
      @Override public boolean apply(      TaskGroup taskGroup){
        return taskGroup.getTaskSet().contains(task);
      }
    }
));
    final TaskGroup taskGroup;
    if (maybeTaskGroup.size() == 1) {
      taskGroup=maybeTaskGroup.get(0);
    }
 else {
      throw new IllegalStateException(String.format("Task must be running: %s",task.getId()));
    }
    log.info("Removing task[%s] from TaskGroup[%s]",task.getId(),taskGroup.getGroupId());
    taskGroup.getTaskSet().remove(task);
    if (taskGroup.getTaskSet().size() == 0) {
      log.info("TaskGroup complete: %s",taskGroup);
      running.get(dataSource).remove(taskGroup.getInterval());
    }
    if (running.get(dataSource).size() == 0) {
      running.remove(dataSource);
    }
    workMayBeAvailable.signalAll();
  }
  finally {
    giant.unlock();
  }
}
