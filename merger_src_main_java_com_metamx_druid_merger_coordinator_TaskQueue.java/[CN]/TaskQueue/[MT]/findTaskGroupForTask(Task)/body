{
  giant.lock();
  try {
    final Iterator<TaskGroup> maybeTaskGroup=FunctionalIterable.create(findTaskGroupsForInterval(task.getDataSource(),task.getInterval())).filter(new Predicate<TaskGroup>(){
      @Override public boolean apply(      TaskGroup taskGroup){
        return taskGroup.contains(task.getId());
      }
    }
).iterator();
    if (!maybeTaskGroup.hasNext()) {
      return Optional.absent();
    }
 else {
      return Optional.of(Iterators.getOnlyElement(maybeTaskGroup));
    }
  }
  finally {
    giant.unlock();
  }
}
