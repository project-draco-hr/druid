{
  final MasterStats stats=new MasterStats();
  final DateTime referenceTimestamp=params.getBalancerReferenceTimestamp();
  final BalancerCostAnalyzer analyzer=params.getBalancerCostAnalyzer(referenceTimestamp);
  final int maxSegmentsToMove=params.getMasterSegmentSettings().getMaxSegmentsToMove();
  for (  Map.Entry<String,MinMaxPriorityQueue<ServerHolder>> entry : params.getDruidCluster().getCluster().entrySet()) {
    String tier=entry.getKey();
    if (currentlyMovingSegments.get(tier) == null) {
      currentlyMovingSegments.put(tier,new ConcurrentHashMap<String,BalancerSegmentHolder>());
    }
    if (!currentlyMovingSegments.get(tier).isEmpty()) {
      reduceLifetimes(tier);
      log.info("[%s]: Still waiting on %,d segments to be moved",tier,currentlyMovingSegments.size());
      continue;
    }
    final List<ServerHolder> serverHolderList=Lists.newArrayList(entry.getValue());
    if (serverHolderList.size() <= 1) {
      log.info("[%s]: One or fewer servers found.  Cannot balance.",tier);
      continue;
    }
    int numSegments=0;
    for (    ServerHolder server : serverHolderList) {
      numSegments+=server.getServer().getSegments().size();
    }
    if (numSegments == 0) {
      log.info("No segments found.  Cannot balance.");
      continue;
    }
    for (int iter=0; iter < maxSegmentsToMove; iter++) {
      final BalancerSegmentHolder segmentToMove=analyzer.pickSegmentToMove(serverHolderList);
      if (params.getAvailableSegments().contains(segmentToMove.getSegment())) {
        final ServerHolder holder=analyzer.findNewSegmentHomeBalance(segmentToMove.getSegment(),serverHolderList);
        if (holder != null) {
          moveSegment(segmentToMove,holder.getServer(),params);
        }
      }
    }
    final double initialTotalCost=analyzer.calculateInitialTotalCost(serverHolderList);
    final double normalization=analyzer.calculateNormalization(serverHolderList);
    final double normalizedInitialCost=initialTotalCost / normalization;
    stats.addToTieredStat("initialCost",tier,(long)initialTotalCost);
    stats.addToTieredStat("normalization",tier,(long)normalization);
    stats.addToTieredStat("normalizedInitialCostTimesOneThousand",tier,(long)(normalizedInitialCost * 1000));
    stats.addToTieredStat("movedCount",tier,currentlyMovingSegments.get(tier).size());
    log.info("[%s]: Initial Total Cost: [%f], Normalization: [%f], Initial Normalized Cost: [%f], Segments Moved: [%d]",tier,initialTotalCost,normalization,normalizedInitialCost,currentlyMovingSegments.get(tier).size());
  }
  return params.buildFromExisting().withMasterStats(stats).build();
}
