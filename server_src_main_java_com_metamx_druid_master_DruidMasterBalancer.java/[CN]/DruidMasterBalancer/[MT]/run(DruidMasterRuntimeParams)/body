{
  MasterStats stats=new MasterStats();
  for (  Map.Entry<String,MinMaxPriorityQueue<ServerHolder>> entry : params.getDruidCluster().getCluster().entrySet()) {
    String tier=entry.getKey();
    if (currentlyMovingSegments.get(tier) == null) {
      currentlyMovingSegments.put(tier,new ConcurrentHashMap<String,BalancerSegmentHolder>());
    }
    if (!currentlyMovingSegments.get(tier).isEmpty()) {
      reduceLifetimes(tier);
      log.info("[%s]: Still waiting on %,d segments to be moved",tier,currentlyMovingSegments.size());
      continue;
    }
    List<ServerHolder> serverHolderList=new ArrayList<ServerHolder>(entry.getValue());
    analyzer.init(serverHolderList,params);
    moveSegments(analyzer.findSegmentsToMove(),params);
    double initialTotalCost=analyzer.getInitialTotalCost();
    double normalization=analyzer.getNormalization();
    double normalizedInitialCost=analyzer.getNormalizedInitialCost();
    double costChange=analyzer.getTotalCostChange();
    stats.addToTieredStat("initialCost",tier,(long)initialTotalCost);
    stats.addToTieredStat("normalization",tier,(long)normalization);
    stats.addToTieredStat("costChange",tier,(long)costChange);
    log.info("Initial Total Cost: [%f], Initial Normalized Cost: [%f], Cost Change: [%f], Normalized Cost Change: [%f], New Normalized Cost: [%f]",initialTotalCost,normalizedInitialCost,costChange,costChange / normalization,(initialTotalCost - costChange) / normalization);
    if (serverHolderList.size() <= 1) {
      log.info("[%s]: One or fewer servers found.  Cannot balance.",tier);
      continue;
    }
    stats.addToTieredStat("movedCount",tier,currentlyMovingSegments.get(tier).size());
  }
  return params.buildFromExisting().withMasterStats(stats).build();
}
