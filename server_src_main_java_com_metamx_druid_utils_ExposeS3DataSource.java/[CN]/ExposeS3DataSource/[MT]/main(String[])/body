{
  CLI cli=new CLI();
  cli.addOption(new RequiredOption(null,"s3Bucket",true,"s3 bucket to pull data from"));
  cli.addOption(new RequiredOption(null,"s3Path",true,"base input path in s3 bucket.  Everything until the date strings."));
  cli.addOption(new RequiredOption(null,"timeInterval",true,"ISO8601 interval of dates to index"));
  cli.addOption(new RequiredOption(null,"granularity",true,String.format("granularity of index, supported granularities: [%s]",Arrays.asList(Granularity.values()))));
  cli.addOption(new RequiredOption(null,"zkCluster",true,"Cluster string to connect to ZK with."));
  cli.addOption(new RequiredOption(null,"zkBasePath",true,"The base path to register index changes to."));
  CommandLine commandLine=cli.parse(args);
  if (commandLine == null) {
    return;
  }
  String s3Bucket=commandLine.getOptionValue("s3Bucket");
  String s3Path=commandLine.getOptionValue("s3Path");
  String timeIntervalString=commandLine.getOptionValue("timeInterval");
  String granularity=commandLine.getOptionValue("granularity");
  String zkCluster=commandLine.getOptionValue("zkCluster");
  String zkBasePath=commandLine.getOptionValue("zkBasePath");
  Interval timeInterval=new Interval(timeIntervalString);
  Granularity gran=Granularity.valueOf(granularity.toUpperCase());
  final RestS3Service s3Client=new RestS3Service(new AWSCredentials(System.getProperty("com.metamx.aws.accessKey"),System.getProperty("com.metamx.aws.secretKey")));
  ZkClient zkClient=new ZkClient(new ZkConnection(zkCluster),Integer.MAX_VALUE,new StringZkSerializer());
  zkClient.waitUntilConnected();
  for (  Interval interval : gran.getIterable(timeInterval)) {
    log.info("Processing interval[%s]",interval);
    String s3DatePath=JOINER.join(s3Path,gran.toPath(interval.getStart()));
    if (!s3DatePath.endsWith("/")) {
      s3DatePath+="/";
    }
    StorageObjectsChunk chunk=s3Client.listObjectsChunked(s3Bucket,s3DatePath,"/",2000,null,true);
    TreeSet<String> commonPrefixes=Sets.newTreeSet();
    commonPrefixes.addAll(Arrays.asList(chunk.getCommonPrefixes()));
    if (commonPrefixes.isEmpty()) {
      log.info("Nothing at s3://%s/%s",s3Bucket,s3DatePath);
      continue;
    }
    String latestPrefix=commonPrefixes.last();
    log.info("Latest segments at [s3://%s/%s]",s3Bucket,latestPrefix);
    chunk=s3Client.listObjectsChunked(s3Bucket,latestPrefix,"/",2000,null,true);
    Integer partitionNumber;
    if (chunk.getCommonPrefixes().length == 0) {
      partitionNumber=null;
    }
 else {
      partitionNumber=-1;
      for (      String partitionPrefix : chunk.getCommonPrefixes()) {
        String[] splits=partitionPrefix.split("/");
        partitionNumber=Math.max(partitionNumber,Integer.parseInt(splits[splits.length - 1]));
      }
    }
    log.info("Highest segment partition[%,d]",partitionNumber);
    if (partitionNumber == null) {
      final S3Object s3Obj=new S3Object(new S3Bucket(s3Bucket),String.format("%sdescriptor.json",latestPrefix));
      updateWithS3Object(zkBasePath,s3Client,zkClient,s3Obj);
    }
 else {
      for (int i=partitionNumber; i >= 0; --i) {
        final S3Object partitionObject=new S3Object(new S3Bucket(s3Bucket),String.format("%s%s/descriptor.json",latestPrefix,i));
        updateWithS3Object(zkBasePath,s3Client,zkClient,partitionObject);
      }
    }
  }
}
