{
  final CountDownLatch latch=new CountDownLatch(5);
  final CountDownLatch latchMore=new CountDownLatch(10);
  final AtomicLong runs=new AtomicLong(0);
  long prior=0;
  final URIExtractionNamespace namespace=new URIExtractionNamespace(ns,tmpFile.toURI(),new URIExtractionNamespace.ObjectMapperFlatDataParser(URIExtractionNamespaceTest.registerTypes(new ObjectMapper())),new Period(1l),null);
  final String cacheId=UUID.randomUUID().toString();
  final CountDownLatch latchBeforeMore=new CountDownLatch(1);
  ListenableFuture<?> future=manager.schedule(namespace,factory,new Runnable(){
    @Override public void run(){
      try {
        if (!Thread.interrupted()) {
          manager.getPostRunnable(namespace,factory,cacheId).run();
        }
 else {
          Thread.currentThread().interrupt();
        }
        if (!Thread.interrupted()) {
          runs.incrementAndGet();
        }
 else {
          Thread.currentThread().interrupt();
        }
      }
  finally {
        latch.countDown();
        try {
          if (latch.getCount() == 0) {
            latchBeforeMore.await();
          }
        }
 catch (        InterruptedException e) {
          log.debug("Interrupted");
          Thread.currentThread().interrupt();
        }
 finally {
          latchMore.countDown();
        }
      }
    }
  }
,cacheId);
  latch.await();
  prior=runs.get();
  latchBeforeMore.countDown();
  Assert.assertFalse(future.isCancelled());
  Assert.assertFalse(future.isDone());
  Assert.assertTrue(fnCache.containsKey(ns));
  latchMore.await();
  Assert.assertTrue(runs.get() > prior);
  Assert.assertTrue(manager.implData.containsKey(ns));
  manager.delete("ns");
  Assert.assertFalse(manager.implData.containsKey(ns));
  Assert.assertFalse(fnCache.containsKey(ns));
  Assert.assertTrue(future.isCancelled());
  Assert.assertTrue(future.isDone());
  prior=runs.get();
  Thread.sleep(20);
  Assert.assertEquals(prior,runs.get());
}
