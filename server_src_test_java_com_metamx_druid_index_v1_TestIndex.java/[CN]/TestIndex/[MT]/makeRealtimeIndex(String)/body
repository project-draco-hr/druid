{
  URL resource=TestIndex.class.getClassLoader().getResource(resourceFilename);
  String filename=resource.getFile();
  log.info("Realtime loading index file[%s]",filename);
  final IncrementalIndex retVal=new IncrementalIndex(new DateTime("2011-01-12T00:00:00.000Z").getMillis(),QueryGranularity.NONE,METRIC_AGGS);
  final AtomicLong startTime=new AtomicLong();
  int lineCount;
  try {
    lineCount=CharStreams.readLines(GuavaUtils.joinFiles(new File(filename)),new LineProcessor<Integer>(){
      boolean runOnce=false;
      int lineCount=0;
      @Override public boolean processLine(      String line) throws IOException {
        if (!runOnce) {
          startTime.set(System.currentTimeMillis());
          runOnce=true;
        }
        final String[] splits=line.split("\t");
        retVal.add(new InputRow(){
          @Override public long getTimestampFromEpoch(){
            return new DateTime(splits[0]).getMillis();
          }
          @Override public List<String> getDimensions(){
            return Arrays.asList(DIMENSIONS);
          }
          @Override public List<String> getDimension(          String dimension){
            return Arrays.asList(splits[dimIds.get(dimension) + 1].split("\u0001"));
          }
          @Override public float getFloatMetric(          String metric){
            Preconditions.checkArgument(METRICS[0].equals(metric),"WTF!?");
            return Float.parseFloat(splits[5]);
          }
        }
);
        ++lineCount;
        return true;
      }
      @Override public Integer getResult(){
        return lineCount;
      }
    }
);
  }
 catch (  IOException e) {
    realtimeIndex=null;
    throw Throwables.propagate(e);
  }
  log.info("Loaded %,d lines in %,d millis.",lineCount,System.currentTimeMillis() - startTime.get());
  return retVal;
}
