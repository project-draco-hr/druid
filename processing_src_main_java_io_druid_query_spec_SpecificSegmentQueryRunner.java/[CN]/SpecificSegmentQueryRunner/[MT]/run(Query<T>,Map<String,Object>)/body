{
  final Query<T> query=input.withQuerySegmentSpec(specificSpec);
  final Thread currThread=Thread.currentThread();
  final String currThreadName=currThread.getName();
  final String newName=String.format("%s_%s_%s",query.getType(),query.getDataSource(),query.getIntervals());
  final Sequence<T> baseSequence=doNamed(currThread,currThreadName,newName,new Callable<Sequence<T>>(){
    @Override public Sequence<T> call() throws Exception {
      Sequence<T> returningSeq;
      try {
        returningSeq=base.run(query,context);
      }
 catch (      NullStorageAdapterException e) {
        ((List)context.get("missingSegments")).add(((SpecificSegmentSpec)specificSpec).getDescriptor());
        returningSeq=Sequences.empty();
      }
      return returningSeq;
    }
  }
);
  return new Sequence<T>(){
    @Override public <OutType>OutType accumulate(    final OutType initValue,    final Accumulator<OutType,T> accumulator){
      return doItNamed(new Callable<OutType>(){
        @Override public OutType call() throws Exception {
          return baseSequence.accumulate(initValue,accumulator);
        }
      }
);
    }
    @Override public <OutType>Yielder<OutType> toYielder(    final OutType initValue,    final YieldingAccumulator<OutType,T> accumulator){
      return doItNamed(new Callable<Yielder<OutType>>(){
        @Override public Yielder<OutType> call() throws Exception {
          return makeYielder(baseSequence.toYielder(initValue,accumulator));
        }
      }
);
    }
    private <OutType>Yielder<OutType> makeYielder(    final Yielder<OutType> yielder){
      return new Yielder<OutType>(){
        @Override public OutType get(){
          return yielder.get();
        }
        @Override public Yielder<OutType> next(        final OutType initValue){
          return doItNamed(new Callable<Yielder<OutType>>(){
            @Override public Yielder<OutType> call() throws Exception {
              return yielder.next(initValue);
            }
          }
);
        }
        @Override public boolean isDone(){
          return yielder.isDone();
        }
        @Override public void close() throws IOException {
          yielder.close();
        }
      }
;
    }
    private <RetType>RetType doItNamed(    Callable<RetType> toRun){
      return doNamed(currThread,currThreadName,newName,toRun);
    }
  }
;
}
