{
  if (index.isEmpty()) {
    return ImmutableList.of();
  }
  Interval actualIntervalTmp=interval;
  final Interval dataInterval=new Interval(getMinTime().getMillis(),gran.next(getMaxTime().getMillis()));
  if (!actualIntervalTmp.overlaps(dataInterval)) {
    return ImmutableList.of();
  }
  if (actualIntervalTmp.getStart().isBefore(dataInterval.getStart())) {
    actualIntervalTmp=actualIntervalTmp.withStart(dataInterval.getStart());
  }
  if (actualIntervalTmp.getEnd().isAfter(dataInterval.getEnd())) {
    actualIntervalTmp=actualIntervalTmp.withEnd(dataInterval.getEnd());
  }
  final Interval actualInterval=actualIntervalTmp;
  return new Iterable<Cursor>(){
    @Override public Iterator<Cursor> iterator(){
      return FunctionalIterator.create(gran.iterable(actualInterval.getStartMillis(),actualInterval.getEndMillis()).iterator()).transform(new Function<Long,Cursor>(){
        EntryHolder currEntry=new EntryHolder();
        private final ValueMatcher filterMatcher;
{
          filterMatcher=makeFilterMatcher(filter,currEntry);
        }
        @Override public Cursor apply(        @Nullable final Long input){
          final long timeStart=Math.max(input,actualInterval.getStartMillis());
          return new Cursor(){
            private Iterator<Map.Entry<IncrementalIndex.TimeAndDims,Aggregator[]>> baseIter;
            private ConcurrentNavigableMap<IncrementalIndex.TimeAndDims,Aggregator[]> cursorMap;
            final DateTime time;
            int numAdvanced=-1;
            boolean done;
{
              cursorMap=index.getSubMap(new IncrementalIndex.TimeAndDims(timeStart,new String[][]{}),new IncrementalIndex.TimeAndDims(Math.min(actualInterval.getEndMillis(),gran.next(input)),new String[][]{}));
              time=gran.toDateTime(input);
              reset();
            }
            @Override public DateTime getTime(){
              return time;
            }
            @Override public void advance(){
              if (!baseIter.hasNext()) {
                done=true;
                return;
              }
              while (baseIter.hasNext()) {
                currEntry.set(baseIter.next());
                if (filterMatcher.matches()) {
                  return;
                }
              }
              if (!filterMatcher.matches()) {
                done=true;
              }
            }
            @Override public void advanceTo(            int offset){
              int count=0;
              while (count < offset && !isDone()) {
                advance();
                count++;
              }
            }
            @Override public boolean isDone(){
              return done;
            }
            @Override public void reset(){
              baseIter=cursorMap.entrySet().iterator();
              if (numAdvanced == -1) {
                numAdvanced=0;
              }
 else {
                Iterators.advance(baseIter,numAdvanced);
              }
              while (baseIter.hasNext()) {
                currEntry.set(baseIter.next());
                if (filterMatcher.matches()) {
                  return;
                }
                numAdvanced++;
              }
              done=cursorMap.size() == 0 || !baseIter.hasNext();
            }
            @Override public TimestampColumnSelector makeTimestampColumnSelector(){
              return new TimestampColumnSelector(){
                @Override public long getTimestamp(){
                  return currEntry.getKey().getTimestamp();
                }
              }
;
            }
            @Override public DimensionSelector makeDimensionSelector(            String dimension){
              final String dimensionName=dimension.toLowerCase();
              final IncrementalIndex.DimDim dimValLookup=index.getDimension(dimensionName);
              if (dimValLookup == null) {
                return null;
              }
              final int maxId=dimValLookup.size();
              final int dimIndex=index.getDimensionIndex(dimensionName);
              return new DimensionSelector(){
                @Override public IndexedInts getRow(){
                  final ArrayList<Integer> vals=Lists.newArrayList();
                  if (dimIndex < currEntry.getKey().getDims().length) {
                    final String[] dimVals=currEntry.getKey().getDims()[dimIndex];
                    if (dimVals != null) {
                      for (                      String dimVal : dimVals) {
                        int id=dimValLookup.getId(dimVal);
                        if (id < maxId) {
                          vals.add(id);
                        }
                      }
                    }
                  }
                  return new IndexedInts(){
                    @Override public int size(){
                      return vals.size();
                    }
                    @Override public int get(                    int index){
                      return vals.get(index);
                    }
                    @Override public Iterator<Integer> iterator(){
                      return vals.iterator();
                    }
                  }
;
                }
                @Override public int getValueCardinality(){
                  return maxId;
                }
                @Override public String lookupName(                int id){
                  return dimValLookup.getValue(id);
                }
                @Override public int lookupId(                String name){
                  return dimValLookup.getId(name);
                }
              }
;
            }
            @Override public FloatColumnSelector makeFloatColumnSelector(            String columnName){
              final String metricName=columnName.toLowerCase();
              final Integer metricIndexInt=index.getMetricIndex(metricName);
              if (metricIndexInt == null) {
                return new FloatColumnSelector(){
                  @Override public float get(){
                    return 0.0f;
                  }
                }
;
              }
              final int metricIndex=metricIndexInt;
              return new FloatColumnSelector(){
                @Override public float get(){
                  return currEntry.getValue()[metricIndex].getFloat();
                }
              }
;
            }
            @Override public ObjectColumnSelector makeObjectColumnSelector(            String column){
              final String columnName=column.toLowerCase();
              final Integer metricIndexInt=index.getMetricIndex(columnName);
              if (metricIndexInt != null) {
                final int metricIndex=metricIndexInt;
                final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(index.getMetricType(columnName));
                return new ObjectColumnSelector(){
                  @Override public Class classOfObject(){
                    return serde.getObjectStrategy().getClazz();
                  }
                  @Override public Object get(){
                    return currEntry.getValue()[metricIndex].get();
                  }
                }
;
              }
              final Integer dimensionIndexInt=index.getDimensionIndex(columnName);
              if (dimensionIndexInt != null) {
                final int dimensionIndex=dimensionIndexInt;
                return new ObjectColumnSelector<String>(){
                  @Override public Class classOfObject(){
                    return String.class;
                  }
                  @Override public String get(){
                    final String[] dimVals=currEntry.getKey().getDims()[dimensionIndex];
                    if (dimVals.length == 1) {
                      return dimVals[0];
                    }
                    if (dimVals.length == 0) {
                      return null;
                    }
                    throw new UnsupportedOperationException("makeObjectColumnSelector does not support multivalued columns");
                  }
                }
;
              }
              return null;
            }
          }
;
        }
      }
);
    }
  }
;
}
