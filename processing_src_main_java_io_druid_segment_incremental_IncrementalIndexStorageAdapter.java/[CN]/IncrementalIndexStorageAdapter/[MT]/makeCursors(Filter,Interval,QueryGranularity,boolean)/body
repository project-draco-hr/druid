{
  if (index.isEmpty()) {
    return Sequences.empty();
  }
  Interval actualIntervalTmp=interval;
  final Interval dataInterval=new Interval(getMinTime().getMillis(),gran.next(gran.truncate(getMaxTime().getMillis())));
  if (!actualIntervalTmp.overlaps(dataInterval)) {
    return Sequences.empty();
  }
  if (actualIntervalTmp.getStart().isBefore(dataInterval.getStart())) {
    actualIntervalTmp=actualIntervalTmp.withStart(dataInterval.getStart());
  }
  if (actualIntervalTmp.getEnd().isAfter(dataInterval.getEnd())) {
    actualIntervalTmp=actualIntervalTmp.withEnd(dataInterval.getEnd());
  }
  final Interval actualInterval=actualIntervalTmp;
  Iterable<Long> iterable=gran.iterable(actualInterval.getStartMillis(),actualInterval.getEndMillis());
  if (descending) {
    iterable=Lists.reverse(ImmutableList.copyOf(iterable));
  }
  return Sequences.map(Sequences.simple(iterable),new Function<Long,Cursor>(){
    EntryHolder currEntry=new EntryHolder();
    private final ValueMatcher filterMatcher;
{
      filterMatcher=makeFilterMatcher(filter,currEntry);
    }
    @Override public Cursor apply(    @Nullable final Long input){
      final long timeStart=Math.max(input,actualInterval.getStartMillis());
      return new Cursor(){
        private Iterator<Map.Entry<IncrementalIndex.TimeAndDims,Integer>> baseIter;
        private ConcurrentNavigableMap<IncrementalIndex.TimeAndDims,Integer> cursorMap;
        final DateTime time;
        int numAdvanced=-1;
        boolean done;
{
          cursorMap=index.getSubMap(new IncrementalIndex.TimeAndDims(timeStart,new int[][]{},null),new IncrementalIndex.TimeAndDims(Math.min(actualInterval.getEndMillis(),gran.next(input)),new int[][]{},null));
          if (descending) {
            cursorMap=cursorMap.descendingMap();
          }
          time=gran.toDateTime(input);
          reset();
        }
        @Override public DateTime getTime(){
          return time;
        }
        @Override public void advance(){
          if (!baseIter.hasNext()) {
            done=true;
            return;
          }
          while (baseIter.hasNext()) {
            if (Thread.interrupted()) {
              throw new QueryInterruptedException(new InterruptedException());
            }
            currEntry.set(baseIter.next());
            if (filterMatcher.matches()) {
              return;
            }
          }
          if (!filterMatcher.matches()) {
            done=true;
          }
        }
        @Override public void advanceTo(        int offset){
          int count=0;
          while (count < offset && !isDone()) {
            advance();
            count++;
          }
        }
        @Override public boolean isDone(){
          return done;
        }
        @Override public void reset(){
          baseIter=cursorMap.entrySet().iterator();
          if (numAdvanced == -1) {
            numAdvanced=0;
          }
 else {
            Iterators.advance(baseIter,numAdvanced);
          }
          if (Thread.interrupted()) {
            throw new QueryInterruptedException(new InterruptedException());
          }
          boolean foundMatched=false;
          while (baseIter.hasNext()) {
            currEntry.set(baseIter.next());
            if (filterMatcher.matches()) {
              foundMatched=true;
              break;
            }
            numAdvanced++;
          }
          done=!foundMatched && (cursorMap.size() == 0 || !baseIter.hasNext());
        }
        @Override public DimensionSelector makeDimensionSelector(        DimensionSpec dimensionSpec){
          return dimensionSpec.decorate(makeDimensionSelectorUndecorated(dimensionSpec));
        }
        private DimensionSelector makeDimensionSelectorUndecorated(        DimensionSpec dimensionSpec){
          final String dimension=dimensionSpec.getDimension();
          final ExtractionFn extractionFn=dimensionSpec.getExtractionFn();
          if (dimension.equals(Column.TIME_COLUMN_NAME)) {
            return new SingleScanTimeDimSelector(makeLongColumnSelector(dimension),extractionFn,descending);
          }
          final IncrementalIndex.DimensionDesc dimensionDesc=index.getDimension(dimension);
          if (dimensionDesc == null) {
            return NULL_DIMENSION_SELECTOR;
          }
          final int dimIndex=dimensionDesc.getIndex();
          final IncrementalIndex.DimDim dimValLookup=dimensionDesc.getValues();
          final int maxId=dimValLookup.size();
          return new DimensionSelector(){
            @Override public IndexedInts getRow(){
              final int[][] dims=currEntry.getKey().getDims();
              int[] indices=dimIndex < dims.length ? dims[dimIndex] : null;
              List<Integer> valsTmp=null;
              if ((indices == null || indices.length == 0) && dimValLookup.contains(null)) {
                int id=dimValLookup.getId(null);
                if (id < maxId) {
                  valsTmp=new ArrayList<>(1);
                  valsTmp.add(id);
                }
              }
 else               if (indices != null && indices.length > 0) {
                valsTmp=new ArrayList<>(indices.length);
                for (int i=0; i < indices.length; i++) {
                  int id=indices[i];
                  if (id < maxId) {
                    valsTmp.add(id);
                  }
                }
              }
              final List<Integer> vals=valsTmp == null ? Collections.EMPTY_LIST : valsTmp;
              return new IndexedInts(){
                @Override public int size(){
                  return vals.size();
                }
                @Override public int get(                int index){
                  return vals.get(index);
                }
                @Override public Iterator<Integer> iterator(){
                  return vals.iterator();
                }
                @Override public void fill(                int index,                int[] toFill){
                  throw new UnsupportedOperationException("fill not supported");
                }
                @Override public void close() throws IOException {
                }
              }
;
            }
            @Override public int getValueCardinality(){
              return maxId;
            }
            @Override public String lookupName(            int id){
              final Comparable value=dimValLookup.getValue(id);
              final String strValue=value == null ? null : value.toString();
              return extractionFn == null ? strValue : extractionFn.apply(strValue);
            }
            @Override public int lookupId(            String name){
              if (extractionFn != null) {
                throw new UnsupportedOperationException("cannot perform lookup when applying an extraction function");
              }
              return dimValLookup.getId(name);
            }
          }
;
        }
        @Override public FloatColumnSelector makeFloatColumnSelector(        String columnName){
          final Integer metricIndexInt=index.getMetricIndex(columnName);
          if (metricIndexInt == null) {
            return new FloatColumnSelector(){
              @Override public float get(){
                return 0.0f;
              }
            }
;
          }
          final int metricIndex=metricIndexInt;
          return new FloatColumnSelector(){
            @Override public float get(){
              return index.getMetricFloatValue(currEntry.getValue(),metricIndex);
            }
          }
;
        }
        @Override public LongColumnSelector makeLongColumnSelector(        String columnName){
          if (columnName.equals(Column.TIME_COLUMN_NAME)) {
            return new LongColumnSelector(){
              @Override public long get(){
                return currEntry.getKey().getTimestamp();
              }
            }
;
          }
          final Integer metricIndexInt=index.getMetricIndex(columnName);
          if (metricIndexInt == null) {
            return new LongColumnSelector(){
              @Override public long get(){
                return 0L;
              }
            }
;
          }
          final int metricIndex=metricIndexInt;
          return new LongColumnSelector(){
            @Override public long get(){
              return index.getMetricLongValue(currEntry.getValue(),metricIndex);
            }
          }
;
        }
        @Override public ObjectColumnSelector makeObjectColumnSelector(        String column){
          if (column.equals(Column.TIME_COLUMN_NAME)) {
            return new ObjectColumnSelector<Long>(){
              @Override public Class classOfObject(){
                return Long.TYPE;
              }
              @Override public Long get(){
                return currEntry.getKey().getTimestamp();
              }
            }
;
          }
          final Integer metricIndexInt=index.getMetricIndex(column);
          if (metricIndexInt != null) {
            final int metricIndex=metricIndexInt;
            final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(index.getMetricType(column));
            return new ObjectColumnSelector(){
              @Override public Class classOfObject(){
                return serde.getObjectStrategy().getClazz();
              }
              @Override public Object get(){
                return index.getMetricObjectValue(currEntry.getValue(),metricIndex);
              }
            }
;
          }
          IncrementalIndex.DimensionDesc dimensionDesc=index.getDimension(column);
          if (dimensionDesc != null) {
            final int dimensionIndex=dimensionDesc.getIndex();
            final IncrementalIndex.DimDim dimDim=dimensionDesc.getValues();
            return new ObjectColumnSelector<Object>(){
              @Override public Class classOfObject(){
                return Object.class;
              }
              @Override public Object get(){
                IncrementalIndex.TimeAndDims key=currEntry.getKey();
                if (key == null) {
                  return null;
                }
                int[][] dims=key.getDims();
                if (dimensionIndex >= dims.length) {
                  return null;
                }
                final int[] dimIdx=dims[dimensionIndex];
                if (dimIdx == null || dimIdx.length == 0) {
                  return null;
                }
                if (dimIdx.length == 1) {
                  return dimDim.getValue(dimIdx[0]);
                }
                Comparable[] dimVals=new String[dimIdx.length];
                for (int i=0; i < dimIdx.length; i++) {
                  dimVals[i]=dimDim.getValue(dimIdx[i]);
                }
                return dimVals;
              }
            }
;
          }
          return null;
        }
      }
;
    }
  }
);
}
