{
  final ListenableFuture<?> setupFuture=setupTeardownService.submit(new Runnable(){
    @Override public void run(){
      final Handle handle=derbyConnectorRule.getConnector().getDBI().open();
      handleRef.set(handle);
      Assert.assertEquals(0,handle.createStatement(String.format("CREATE TABLE %s (%s TIMESTAMP, %s VARCHAR(64), %s VARCHAR(64))",tableName,tsColumn_,keyName,valName)).setQueryTimeout(1).execute());
      handle.createStatement(String.format("TRUNCATE TABLE %s",tableName)).setQueryTimeout(1).execute();
      handle.commit();
      closer.register(new Closeable(){
        @Override public void close() throws IOException {
          handle.createStatement("DROP TABLE " + tableName).setQueryTimeout(1).execute();
          handle.close();
        }
      }
);
      closer.register(new Closeable(){
        @Override public void close() throws IOException {
          final NamespaceExtractionCacheManager.NamespaceImplData implData=extractionCacheManager.implData.get(namespace);
          if (implData != null && implData.future != null) {
            implData.future.cancel(true);
            Assert.assertTrue(implData.future.isDone());
          }
        }
      }
);
      for (      Map.Entry<String,String> entry : renames.entrySet()) {
        try {
          insertValues(entry.getKey(),entry.getValue(),"2015-01-01 00:00:00");
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          throw Throwables.propagate(e);
        }
      }
      extractionCacheManager=new OnHeapNamespaceExtractionCacheManager(lifecycle,fnCache,reverseFnCache,new NoopServiceEmitter(),ImmutableMap.<Class<? extends ExtractionNamespace>,ExtractionNamespaceFunctionFactory<?>>of(JDBCExtractionNamespace.class,new JDBCExtractionNamespaceFunctionFactory(){
        @Override public Callable<String> getCachePopulator(        final JDBCExtractionNamespace namespace,        final String lastVersion,        final Map<String,String> cache){
          final Callable<String> cachePopulator=super.getCachePopulator(namespace,lastVersion,cache);
          return new Callable<String>(){
            @Override public String call() throws Exception {
              updateLock.lockInterruptibly();
              try {
                log.debug("Running cache populator");
                try {
                  return cachePopulator.call();
                }
  finally {
                  updates.incrementAndGet();
                }
              }
  finally {
                updateLock.unlock();
              }
            }
          }
;
        }
      }
));
      try {
        lifecycle.start();
      }
 catch (      Exception e) {
        throw Throwables.propagate(e);
      }
      closer.register(new Closeable(){
        @Override public void close() throws IOException {
          lifecycle.stop();
        }
      }
);
      closer.register(new Closeable(){
        @Override public void close() throws IOException {
          Assert.assertTrue("Delete failed",extractionCacheManager.delete(namespace));
        }
      }
);
    }
  }
);
  final Closer setupCloser=Closer.create();
  setupCloser.register(new Closeable(){
    @Override public void close() throws IOException {
      if (!setupFuture.isDone() && !setupFuture.cancel(true) && !setupFuture.isDone()) {
        throw new IOException("Unable to stop future");
      }
    }
  }
);
  try {
    setupFuture.get(10,TimeUnit.SECONDS);
  }
 catch (  Throwable t) {
    throw setupCloser.rethrow(t);
  }
 finally {
    setupCloser.close();
  }
}
