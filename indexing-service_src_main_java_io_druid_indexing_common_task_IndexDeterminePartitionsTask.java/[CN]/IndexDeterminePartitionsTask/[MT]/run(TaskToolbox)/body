{
  log.info("Running with targetPartitionSize[%d]",targetPartitionSize);
  final Interval interval=getImplicitLockInterval().get();
  final Set<String> unusableDimensions=Sets.newHashSet();
  final Map<String,TreeMultiset<String>> dimensionValueMultisets=Maps.newHashMap();
  final Firehose firehose=firehoseFactory.connect();
  try {
    while (firehose.hasMore()) {
      final InputRow inputRow=firehose.nextRow();
      if (interval.contains(inputRow.getTimestampFromEpoch())) {
        for (        final String dim : inputRow.getDimensions()) {
          final List<String> dimValues=inputRow.getDimension(dim);
          if (!unusableDimensions.contains(dim)) {
            if (dimValues.size() == 1) {
              TreeMultiset<String> dimensionValueMultiset=dimensionValueMultisets.get(dim);
              if (dimensionValueMultiset == null) {
                dimensionValueMultiset=TreeMultiset.create();
                dimensionValueMultisets.put(dim,dimensionValueMultiset);
              }
              dimensionValueMultiset.add(dimValues.get(0));
            }
 else {
              unusableDimensions.add(dim);
              dimensionValueMultisets.remove(dim);
            }
          }
        }
      }
    }
  }
  finally {
    firehose.close();
  }
  final List<ShardSpec> shardSpecs=Lists.newArrayList();
  Ordering<Map.Entry<String,TreeMultiset<String>>> byCardinalityOrdering=new Ordering<Map.Entry<String,TreeMultiset<String>>>(){
    @Override public int compare(    Map.Entry<String,TreeMultiset<String>> left,    Map.Entry<String,TreeMultiset<String>> right){
      return Ints.compare(left.getValue().elementSet().size(),right.getValue().elementSet().size());
    }
  }
;
  if (dimensionValueMultisets.isEmpty()) {
    log.info("No suitable partition dimension found");
    shardSpecs.add(new NoneShardSpec());
  }
 else {
    final Map.Entry<String,TreeMultiset<String>> partitionEntry=byCardinalityOrdering.max(dimensionValueMultisets.entrySet());
    final String partitionDim=partitionEntry.getKey();
    final TreeMultiset<String> partitionDimValues=partitionEntry.getValue();
    log.info("Partitioning on dimension[%s] with cardinality[%d] over rows[%d]",partitionDim,partitionDimValues.elementSet().size(),partitionDimValues.size());
    String currentPartitionStart=null;
    int currentPartitionSize=0;
    for (    final String partitionDimValue : partitionDimValues.elementSet()) {
      currentPartitionSize+=partitionDimValues.count(partitionDimValue);
      if (currentPartitionSize >= targetPartitionSize) {
        final ShardSpec shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,partitionDimValue,shardSpecs.size());
        log.info("Adding shard: %s",shardSpec);
        shardSpecs.add(shardSpec);
        currentPartitionSize=partitionDimValues.count(partitionDimValue);
        currentPartitionStart=partitionDimValue;
      }
    }
    if (currentPartitionSize > 0) {
      final ShardSpec shardSpec;
      if (shardSpecs.isEmpty()) {
        shardSpec=new NoneShardSpec();
      }
 else {
        shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,null,shardSpecs.size());
      }
      log.info("Adding shard: %s",shardSpec);
      shardSpecs.add(shardSpec);
    }
  }
  List<Task> nextTasks=Lists.transform(shardSpecs,new Function<ShardSpec,Task>(){
    @Override public Task apply(    ShardSpec shardSpec){
      return new IndexGeneratorTask(null,getGroupId(),getImplicitLockInterval().get(),firehoseFactory,new Schema(schema.getDataSource(),schema.getSpatialDimensions(),schema.getAggregators(),schema.getIndexGranularity(),shardSpec),rowFlushBoundary);
    }
  }
);
  toolbox.getTaskActionClient().submit(new SpawnTasksAction(nextTasks));
  return TaskStatus.success(getId());
}
