{
  final CacheStrategy strategy=toolChest.getCacheStrategy(query);
  final boolean populateCache=query.getContextPopulateCache(true) && strategy != null && cacheConfig.isPopulateCache();
  if (populateCache) {
    final Cache.NamedKey key=CacheUtil.computeSegmentCacheKey(segmentIdentifier,segmentDescriptor,strategy.computeCacheKey(query));
    final Function cacheFn=strategy.prepareForCache();
    final List<Object> cacheResults=Lists.newLinkedList();
    return Sequences.withEffect(Sequences.map(base.run(query),new Function<T,T>(){
      @Nullable @Override public T apply(      @Nullable T input){
        cacheResults.add(cacheFn.apply(input));
        return input;
      }
    }
),new Runnable(){
      @Override public void run(){
        CacheUtil.populate(cache,mapper,key,cacheResults);
      }
    }
,MoreExecutors.sameThreadExecutor());
  }
 else {
    return base.run(query);
  }
}
