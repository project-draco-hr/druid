{
  final String topic=kafkaNamespace.getKafkaTopic();
  final String namespace=kafkaNamespace.getNamespace();
  final ListenableFuture<?> future=executorService.submit(new Runnable(){
    @Override public void run(){
      final Properties privateProperties=new Properties();
      privateProperties.putAll(kafkaProperties);
      privateProperties.setProperty("group.id",UUID.randomUUID().toString());
      ConsumerConnector consumerConnector=new kafka.javaapi.consumer.ZookeeperConsumerConnector(new ConsumerConfig(privateProperties));
      List<KafkaStream<String,String>> streams=consumerConnector.createMessageStreamsByFilter(new Whitelist(Pattern.quote(topic)),1,defaultStringDecoder,defaultStringDecoder);
      if (streams == null || streams.isEmpty()) {
        throw new IAE("Topic [%s] had no streams",topic);
      }
      if (streams.size() > 1) {
        throw new ISE("Topic [%s] has %d streams! expected 1",topic,streams.size());
      }
      backgroundTaskCount.incrementAndGet();
      final KafkaStream<String,String> kafkaStream=streams.get(0);
      final ConsumerIterator<String,String> it=kafkaStream.iterator();
      log.info("Listening to topic [%s] for namespace [%s]",topic,namespace);
      AtomicLong eventCounter=topicEvents.get(namespace);
      if (eventCounter == null) {
        topicEvents.putIfAbsent(namespace,new AtomicLong(0L));
        eventCounter=topicEvents.get(namespace);
      }
      while (it.hasNext()) {
        final MessageAndMetadata<String,String> messageAndMetadata=it.next();
        final String key=messageAndMetadata.key();
        final String message=messageAndMetadata.message();
        if (key == null || message == null) {
          log.error("Bad key/message from topic [%s]: [%s]",topic,messageAndMetadata);
          continue;
        }
        map.put(key,message);
        namespaceVersionMap.put(namespace,Long.toString(eventCounter.incrementAndGet()));
        log.debug("Placed key[%s] val[%s]",key,message);
      }
    }
  }
);
  Futures.addCallback(future,new FutureCallback<Object>(){
    @Override public void onSuccess(    Object result){
      topicEvents.remove(namespace);
    }
    @Override public void onFailure(    Throwable t){
      topicEvents.remove(namespace);
      if (t instanceof java.util.concurrent.CancellationException) {
        log.warn("Cancelled rename task for topic [%s]",topic);
      }
 else {
        Throwables.propagate(t);
      }
    }
  }
,MoreExecutors.sameThreadExecutor());
}
