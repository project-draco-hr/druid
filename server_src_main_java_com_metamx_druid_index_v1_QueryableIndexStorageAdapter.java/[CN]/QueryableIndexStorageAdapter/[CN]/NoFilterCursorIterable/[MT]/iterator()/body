{
  final Map<String,GenericColumn> genericColumnCache=Maps.newHashMap();
  final Map<String,ComplexColumn> complexColumnCache=Maps.newHashMap();
  final Map<String,Object> objectColumnCache=Maps.newHashMap();
  final GenericColumn timestamps=index.getTimeColumn().getGenericColumn();
  final FunctionalIterator<Cursor> retVal=FunctionalIterator.create(gran.iterable(interval.getStartMillis(),interval.getEndMillis()).iterator()).transform(new Function<Long,Cursor>(){
    private int currRow=0;
    @Override public Cursor apply(    final Long input){
      final long timeStart=Math.max(interval.getStartMillis(),input);
      while (currRow < timestamps.length() && timestamps.getLongSingleValueRow(currRow) < timeStart) {
        ++currRow;
      }
      return new Cursor(){
        private final DateTime myBucket=gran.toDateTime(input);
        private final long nextBucket=Math.min(gran.next(myBucket.getMillis()),interval.getEndMillis());
        private final int initRow=currRow;
        @Override public DateTime getTime(){
          return myBucket;
        }
        @Override public void advance(){
          ++currRow;
        }
        @Override public boolean isDone(){
          return currRow >= timestamps.length() || timestamps.getLongSingleValueRow(currRow) >= nextBucket;
        }
        @Override public void reset(){
          currRow=initRow;
        }
        @Override public DimensionSelector makeDimensionSelector(        String dimension){
          final String dimensionName=dimension.toLowerCase();
          final Column columnDesc=index.getColumn(dimensionName);
          if (columnDesc == null) {
            return null;
          }
          final DictionaryEncodedColumn column=columnDesc.getDictionaryEncoding();
          if (columnDesc.getCapabilities().hasMultipleValues()) {
            return new DimensionSelector(){
              @Override public IndexedInts getRow(){
                return column.getMultiValueRow(currRow);
              }
              @Override public int getValueCardinality(){
                return column.getCardinality();
              }
              @Override public String lookupName(              int id){
                final String retVal=column.lookupName(id);
                return retVal == null ? "" : retVal;
              }
              @Override public int lookupId(              String name){
                return column.lookupId(name);
              }
            }
;
          }
 else {
            return new DimensionSelector(){
              @Override public IndexedInts getRow(){
                final int value=column.getSingleValueRow(currRow);
                return new IndexedInts(){
                  @Override public int size(){
                    return 1;
                  }
                  @Override public int get(                  int index){
                    return value;
                  }
                  @Override public Iterator<Integer> iterator(){
                    return Iterators.singletonIterator(value);
                  }
                }
;
              }
              @Override public int getValueCardinality(){
                return column.getCardinality();
              }
              @Override public String lookupName(              int id){
                return column.lookupName(id);
              }
              @Override public int lookupId(              String name){
                return column.lookupId(name);
              }
            }
;
          }
        }
        @Override public FloatMetricSelector makeFloatMetricSelector(        String metric){
          final String metricName=metric.toLowerCase();
          GenericColumn cachedMetricVals=genericColumnCache.get(metricName);
          if (cachedMetricVals == null) {
            Column holder=index.getColumn(metricName);
            if (holder != null && holder.getCapabilities().getType() == ValueType.FLOAT) {
              cachedMetricVals=holder.getGenericColumn();
              genericColumnCache.put(metricName,cachedMetricVals);
            }
          }
          if (cachedMetricVals == null) {
            return new FloatMetricSelector(){
              @Override public float get(){
                return 0.0f;
              }
            }
;
          }
          final GenericColumn metricVals=cachedMetricVals;
          return new FloatMetricSelector(){
            @Override public float get(){
              return metricVals.getFloatSingleValueRow(currRow);
            }
          }
;
        }
        @Override public ComplexMetricSelector makeComplexMetricSelector(        String metric){
          final String metricName=metric.toLowerCase();
          ComplexColumn cachedMetricVals=complexColumnCache.get(metricName);
          if (cachedMetricVals == null) {
            Column holder=index.getColumn(metricName);
            if (holder != null && holder.getCapabilities().getType() == ValueType.COMPLEX) {
              cachedMetricVals=holder.getComplexColumn();
              complexColumnCache.put(metricName,cachedMetricVals);
            }
          }
          if (cachedMetricVals == null) {
            return null;
          }
          final ComplexColumn metricVals=cachedMetricVals;
          return new ComplexMetricSelector(){
            @Override public Class classOfObject(){
              return metricVals.getClazz();
            }
            @Override public Object get(){
              return metricVals.getRowValue(currRow);
            }
          }
;
        }
        @Override public ObjectColumnSelector makeObjectColumnSelector(        String column){
          final String columnName=column.toLowerCase();
          Object cachedColumnVals=objectColumnCache.get(columnName);
          if (cachedColumnVals == null) {
            Column holder=index.getColumn(columnName);
            if (holder != null) {
              if (holder.getCapabilities().hasMultipleValues()) {
                throw new UnsupportedOperationException("makeObjectColumnSelector does not support multivalued columns");
              }
              final ValueType type=holder.getCapabilities().getType();
              if (holder.getCapabilities().isDictionaryEncoded()) {
                cachedColumnVals=holder.getDictionaryEncoding();
              }
 else               if (type == ValueType.COMPLEX) {
                cachedColumnVals=holder.getComplexColumn();
              }
 else {
                cachedColumnVals=holder.getGenericColumn();
              }
            }
            if (cachedColumnVals != null) {
              objectColumnCache.put(columnName,cachedColumnVals);
            }
          }
          if (cachedColumnVals == null) {
            return null;
          }
          if (cachedColumnVals instanceof GenericColumn) {
            final GenericColumn columnVals=(GenericColumn)cachedColumnVals;
            final ValueType type=columnVals.getType();
            if (type == ValueType.FLOAT) {
              return new ObjectColumnSelector<Float>(){
                @Override public Class classOfObject(){
                  return Float.TYPE;
                }
                @Override public Float get(){
                  return columnVals.getFloatSingleValueRow(currRow);
                }
              }
;
            }
            if (type == ValueType.LONG) {
              return new ObjectColumnSelector<Long>(){
                @Override public Class classOfObject(){
                  return Long.TYPE;
                }
                @Override public Long get(){
                  return columnVals.getLongSingleValueRow(currRow);
                }
              }
;
            }
            if (type == ValueType.STRING) {
              return new ObjectColumnSelector<String>(){
                @Override public Class classOfObject(){
                  return String.class;
                }
                @Override public String get(){
                  return columnVals.getStringSingleValueRow(currRow);
                }
              }
;
            }
          }
          if (cachedColumnVals instanceof DictionaryEncodedColumn) {
            final DictionaryEncodedColumn columnVals=(DictionaryEncodedColumn)cachedColumnVals;
            return new ObjectColumnSelector<String>(){
              @Override public Class classOfObject(){
                return String.class;
              }
              @Override public String get(){
                return columnVals.lookupName(columnVals.getSingleValueRow(currRow));
              }
            }
;
          }
          final ComplexColumn columnVals=(ComplexColumn)cachedColumnVals;
          return new ObjectColumnSelector(){
            @Override public Class classOfObject(){
              return columnVals.getClazz();
            }
            @Override public Object get(){
              return columnVals.getRowValue(currRow);
            }
          }
;
        }
      }
;
    }
  }
);
  return MoreIterators.after(retVal,new Runnable(){
    @Override public void run(){
      Closeables.closeQuietly(timestamps);
      for (      GenericColumn column : genericColumnCache.values()) {
        Closeables.closeQuietly(column);
      }
      for (      ComplexColumn complexColumn : complexColumnCache.values()) {
        Closeables.closeQuietly(complexColumn);
      }
      for (      Object column : objectColumnCache.values()) {
        if (column instanceof Closeable)         Closeables.closeQuietly((Closeable)column);
      }
    }
  }
);
}
