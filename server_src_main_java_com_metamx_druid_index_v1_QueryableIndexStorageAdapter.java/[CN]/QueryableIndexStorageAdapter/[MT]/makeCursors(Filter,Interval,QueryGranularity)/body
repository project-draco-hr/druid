{
  Interval actualInterval=interval;
  final Interval dataInterval=new Interval(getMinTime().getMillis(),gran.next(getMaxTime().getMillis()));
  if (!actualInterval.overlaps(dataInterval)) {
    return ImmutableList.of();
  }
  if (actualInterval.getStart().isBefore(dataInterval.getStart())) {
    actualInterval=actualInterval.withStart(dataInterval.getStart());
  }
  if (actualInterval.getEnd().isAfter(dataInterval.getEnd())) {
    actualInterval=actualInterval.withEnd(dataInterval.getEnd());
  }
  final Iterable<Cursor> iterable;
  if (filter == null) {
    iterable=new NoFilterCursorIterable(index,actualInterval,gran);
  }
 else {
    Offset offset=new ConciseOffset(filter.goConcise(new ColumnSelectorBitmapIndexSelector(index)));
    iterable=new CursorIterable(index,actualInterval,gran,offset);
  }
  return FunctionalIterable.create(iterable).keep(Functions.<Cursor>identity());
}
