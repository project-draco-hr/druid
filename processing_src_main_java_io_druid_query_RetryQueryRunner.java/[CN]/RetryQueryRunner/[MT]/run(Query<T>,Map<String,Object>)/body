{
  final List<Sequence<T>> listOfSequences=Lists.newArrayList();
  listOfSequences.add(baseRunner.run(query,responseContext));
  return new YieldingSequenceBase<T>(){
    @Override public <OutType>Yielder<OutType> toYielder(    OutType initValue,    YieldingAccumulator<OutType,T> accumulator){
      doRetryLogic(responseContext,Result.MISSING_SEGMENTS_KEY,new TypeReference<List<SegmentDescriptor>>(){
      }
,new Function<List<SegmentDescriptor>,Query<T>>(){
        @Override public Query<T> apply(        List<SegmentDescriptor> input){
          return query.withQuerySegmentSpec(new MultipleSpecificSegmentSpec(input));
        }
      }
,listOfSequences);
      doRetryLogic(responseContext,Result.MISSING_INTERVALS_KEY,new TypeReference<List<Interval>>(){
      }
,new Function<List<Interval>,Query<T>>(){
        @Override public Query<T> apply(        List<Interval> input){
          return query.withQuerySegmentSpec(new MultipleIntervalSegmentSpec(input));
        }
      }
,listOfSequences);
      return toolChest.mergeSequencesUnordered(Sequences.simple(listOfSequences)).toYielder(initValue,accumulator);
    }
  }
;
}
