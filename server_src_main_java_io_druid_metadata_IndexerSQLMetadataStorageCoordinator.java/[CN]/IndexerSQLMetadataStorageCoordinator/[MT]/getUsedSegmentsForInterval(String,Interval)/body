{
  final VersionedIntervalTimeline<String,DataSegment> timeline=connector.getDBI().withHandle(new HandleCallback<VersionedIntervalTimeline<String,DataSegment>>(){
    @Override public VersionedIntervalTimeline<String,DataSegment> withHandle(    Handle handle) throws IOException {
      final VersionedIntervalTimeline<String,DataSegment> timeline=new VersionedIntervalTimeline<String,DataSegment>(Ordering.natural());
      final ResultIterator<byte[]> dbSegments=handle.createQuery(String.format("SELECT payload FROM %s WHERE used = true AND dataSource = :dataSource",dbTables.getSegmentsTable())).bind("dataSource",dataSource).map(ByteArrayMapper.FIRST).iterator();
      while (dbSegments.hasNext()) {
        final byte[] payload=dbSegments.next();
        DataSegment segment=jsonMapper.readValue(payload,DataSegment.class);
        timeline.add(segment.getInterval(),segment.getVersion(),segment.getShardSpec().createChunk(segment));
      }
      dbSegments.close();
      return timeline;
    }
  }
);
  final List<DataSegment> segments=Lists.transform(timeline.lookup(interval),new Function<TimelineObjectHolder<String,DataSegment>,DataSegment>(){
    @Override public DataSegment apply(    TimelineObjectHolder<String,DataSegment> input){
      return input.getObject().getChunk(0).getObject();
    }
  }
);
  return segments;
}
