{
  verifyState();
  final Period intermediatePersistPeriod=config.getIntermediatePersistPeriod();
  try {
    plumber.startJob();
    long nextFlush=new DateTime().plus(intermediatePersistPeriod).getMillis();
    while (firehose.hasMore()) {
      InputRow inputRow=null;
      try {
        try {
          inputRow=firehose.nextRow();
        }
 catch (        Exception e) {
          log.debug(e,"thrown away line due to exception, considering unparseable");
          metrics.incrementUnparseable();
          continue;
        }
        int currCount=plumber.add(inputRow);
        if (currCount == -1) {
          metrics.incrementThrownAway();
          log.debug("Throwing away event[%s]",inputRow);
          if (System.currentTimeMillis() > nextFlush) {
            plumber.persist(firehose.commit());
            nextFlush=new DateTime().plus(intermediatePersistPeriod).getMillis();
          }
          continue;
        }
        final Sink sink=plumber.getSink(inputRow.getTimestampFromEpoch());
        if ((sink != null && sink.isFull()) || System.currentTimeMillis() > nextFlush) {
          plumber.persist(firehose.commit());
          nextFlush=new DateTime().plus(intermediatePersistPeriod).getMillis();
        }
        metrics.incrementProcessed();
      }
 catch (      ParseException e) {
        if (inputRow != null) {
          log.error(e,"unparseable line: %s",inputRow);
        }
        metrics.incrementUnparseable();
      }
    }
  }
 catch (  RuntimeException e) {
    log.makeAlert(e,"RuntimeException aborted realtime processing[%s]",fireDepartment.getDataSchema().getDataSource()).emit();
    normalExit=false;
    throw e;
  }
catch (  Error e) {
    log.makeAlert(e,"Exception aborted realtime processing[%s]",fireDepartment.getDataSchema().getDataSource()).emit();
    normalExit=false;
    throw e;
  }
 finally {
    CloseQuietly.close(firehose);
    if (normalExit) {
      plumber.finishJob();
      plumber=null;
      firehose=null;
    }
  }
}
