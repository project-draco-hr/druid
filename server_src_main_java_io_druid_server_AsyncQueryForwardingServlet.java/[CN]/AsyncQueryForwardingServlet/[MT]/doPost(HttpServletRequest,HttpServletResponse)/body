{
  final long start=System.currentTimeMillis();
  Query query=null;
  String queryId;
  final boolean isSmile="application/smile".equals(req.getContentType());
  final ObjectMapper objectMapper=isSmile ? smileMapper : jsonMapper;
  OutputStream out=null;
  AsyncContext ctx=null;
  try {
    ctx=req.startAsync(req,resp);
    final AsyncContext asyncContext=ctx;
    if (req.getAttribute(DISPATCHED) != null) {
      return;
    }
    query=objectMapper.readValue(req.getInputStream(),Query.class);
    queryId=query.getId();
    if (queryId == null) {
      queryId=UUID.randomUUID().toString();
      query=query.withId(queryId);
    }
    if (log.isDebugEnabled()) {
      log.debug("Got query [%s]",query);
    }
    out=resp.getOutputStream();
    final OutputStream outputStream=out;
    final String host=hostFinder.getHost(query);
    final Query theQuery=query;
    final String theQueryId=queryId;
    final HttpResponseHandler<OutputStream,OutputStream> responseHandler=new HttpResponseHandler<OutputStream,OutputStream>(){
      @Override public ClientResponse<OutputStream> handleResponse(      HttpResponse response){
        resp.setStatus(response.getStatus().getCode());
        resp.setContentType("application/x-javascript");
        try {
          ChannelBuffer buf=response.getContent();
          buf.readBytes(outputStream,buf.readableBytes());
        }
 catch (        Exception e) {
          asyncContext.complete();
          throw Throwables.propagate(e);
        }
        return ClientResponse.finished(outputStream);
      }
      @Override public ClientResponse<OutputStream> handleChunk(      ClientResponse<OutputStream> clientResponse,      HttpChunk chunk){
        try {
          ChannelBuffer buf=chunk.getContent();
          buf.readBytes(outputStream,buf.readableBytes());
        }
 catch (        Exception e) {
          asyncContext.complete();
          throw Throwables.propagate(e);
        }
        return clientResponse;
      }
      @Override public ClientResponse<OutputStream> done(      ClientResponse<OutputStream> clientResponse){
        final long requestTime=System.currentTimeMillis() - start;
        log.debug("Request time: %d",requestTime);
        emitter.emit(new ServiceMetricEvent.Builder().setUser2(DataSourceUtil.getMetricName(theQuery.getDataSource())).setUser4(theQuery.getType()).setUser5(COMMA_JOIN.join(theQuery.getIntervals())).setUser6(String.valueOf(theQuery.hasFilters())).setUser7(req.getRemoteAddr()).setUser8(theQueryId).setUser9(theQuery.getDuration().toPeriod().toStandardMinutes().toString()).build("request/time",requestTime));
        final OutputStream obj=clientResponse.getObj();
        try {
          requestLogger.log(new RequestLogLine(new DateTime(),req.getRemoteAddr(),theQuery,new QueryStats(ImmutableMap.<String,Object>of("request/time",requestTime,"success",true))));
          resp.flushBuffer();
          outputStream.close();
        }
 catch (        Exception e) {
          throw Throwables.propagate(e);
        }
 finally {
          asyncContext.complete();
        }
        return ClientResponse.finished(obj);
      }
      @Override public void exceptionCaught(      ClientResponse<OutputStream> clientResponse,      Throwable e){
        handleException(resp,asyncContext,e);
      }
    }
;
    asyncContext.start(new Runnable(){
      @Override public void run(){
        routingDruidClient.post(makeUrl(host,req),theQuery,responseHandler);
      }
    }
);
    asyncContext.dispatch();
    req.setAttribute(DISPATCHED,true);
  }
 catch (  Exception e) {
    handleException(resp,ctx,e);
    try {
      requestLogger.log(new RequestLogLine(new DateTime(),req.getRemoteAddr(),query,new QueryStats(ImmutableMap.<String,Object>of("success",false,"exception",e.toString()))));
    }
 catch (    Exception e2) {
      log.error(e2,"Unable to log query [%s]!",query);
    }
    log.makeAlert(e,"Exception handling request").addData("query",query).addData("peer",req.getRemoteAddr()).emit();
  }
}
