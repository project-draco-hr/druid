{
  final ConnectionFactory factory=new ConnectionFactory();
  factory.setHost(consumerProps.getProperty("host",factory.getHost()));
  factory.setUsername(consumerProps.getProperty("username",factory.getUsername()));
  factory.setPassword(consumerProps.getProperty("password",factory.getPassword()));
  factory.setVirtualHost(consumerProps.getProperty("virtualHost",factory.getVirtualHost()));
  boolean durable=Boolean.valueOf(consumerProps.getProperty("durable","false"));
  boolean exclusive=Boolean.valueOf(consumerProps.getProperty("exclusive","false"));
  boolean autoDelete=Boolean.valueOf(consumerProps.getProperty("autoDelete","false"));
  boolean autoAck=Boolean.valueOf(consumerProps.getProperty("autoAck","true"));
  final Connection connection=factory.newConnection();
  final Channel channel=connection.createChannel();
  channel.queueDeclare(queue,durable,exclusive,autoDelete,null);
  channel.queueBind(queue,exchange,routingKey);
  final QueueingConsumer consumer=new QueueingConsumer(channel);
  channel.basicConsume(queue,autoAck,consumer);
  channel.addShutdownListener(new ShutdownListener(){
    @Override public void shutdownCompleted(    ShutdownSignalException cause){
      log.warn(cause,"Channel closed!");
    }
  }
);
  connection.addShutdownListener(new ShutdownListener(){
    @Override public void shutdownCompleted(    ShutdownSignalException cause){
      log.warn(cause,"Connection closed!");
    }
  }
);
  return new Firehose(){
    /** 
 * Storing the latest delivery as a member variable should be safe since this will only be run
 * by a single thread.
 */
    private QueueingConsumer.Delivery delivery;
    /** 
 * Store the latest delivery tag to be able to commit (acknowledge) the message delivery up to
 * and including this tag. See commit() for more detail.
 */
    private long lastDeliveryTag;
    @Override public boolean hasMore(){
      delivery=null;
      try {
        delivery=consumer.nextDelivery();
        lastDeliveryTag=delivery.getEnvelope().getDeliveryTag();
        log.debug("got new message");
      }
 catch (      InterruptedException e) {
        log.wtf(e,"Don't know if this is supposed to ever happen.");
      }
      if (delivery != null) {
        return true;
      }
      return false;
    }
    @Override public InputRow nextRow(){
      if (delivery == null) {
        log.wtf("I have nothing in delivery. Method hasMore() should have returned false.");
        return null;
      }
      return parser.parse(new String(delivery.getBody()));
    }
    @Override public Runnable commit(){
      return new Runnable(){
        final long deliveryTag=lastDeliveryTag;
        @Override public void run(){
          try {
            log.info("Acknowledging delivery of messages up to tag: " + deliveryTag);
            channel.basicAck(deliveryTag,true);
          }
 catch (          IOException e) {
            log.error(e,"Unable to acknowledge message reception to message queue.");
          }
        }
      }
;
    }
    @Override public void close() throws IOException {
      log.info("Closing connection to RabbitMQ");
      channel.close();
      connection.close();
    }
  }
;
}
