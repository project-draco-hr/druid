{
  super(incrementalIndexSchema,deserializeComplexMetrics);
  this.bufferHolder=bufferPool.take();
  Preconditions.checkArgument(maxTotalBufferSize > bufferHolder.get().limit(),"Maximum total buffer size must be greater than aggregation buffer size");
  final AggregatorFactory[] metrics=incrementalIndexSchema.getMetrics();
  this.aggPositionOffsets=new int[metrics.length];
  int currAggSize=0;
  for (int i=0; i < metrics.length; i++) {
    final AggregatorFactory agg=metrics[i];
    aggPositionOffsets[i]=currAggSize;
    currAggSize+=agg.getMaxIntermediateSize();
  }
  this.totalAggSize=currAggSize;
  final DBMaker dbMaker=DBMaker.newMemoryDirectDB().transactionDisable().asyncWriteEnable().cacheLRUEnable().cacheSize(16384);
  this.factsDb=dbMaker.make();
  this.db=dbMaker.make();
  final TimeAndDimsSerializer timeAndDimsSerializer=new TimeAndDimsSerializer(this);
  this.facts=factsDb.createTreeMap("__facts" + UUID.randomUUID()).keySerializer(timeAndDimsSerializer).comparator(timeAndDimsSerializer.getComparator()).valueSerializer(Serializer.INTEGER).make();
  this.maxTotalBufferSize=maxTotalBufferSize;
}
