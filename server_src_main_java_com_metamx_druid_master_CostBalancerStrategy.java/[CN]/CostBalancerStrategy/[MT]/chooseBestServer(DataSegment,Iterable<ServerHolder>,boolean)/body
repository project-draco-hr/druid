{
  Pair<Double,ServerHolder> bestServer=Pair.of(Double.POSITIVE_INFINITY,null);
  MinMaxPriorityQueue<Pair<Double,ServerHolder>> costsAndServers=MinMaxPriorityQueue.orderedBy(new Comparator<Pair<Double,ServerHolder>>(){
    @Override public int compare(    Pair<Double,ServerHolder> o,    Pair<Double,ServerHolder> o1){
      return Double.compare(o.lhs,o1.lhs);
    }
  }
).create();
  final long proposalSegmentSize=proposalSegment.getSize();
  for (  ServerHolder server : serverHolders) {
    if (includeCurrentServer || !server.isServingSegment(proposalSegment)) {
      if (proposalSegmentSize > server.getAvailableSize() || server.isLoadingSegment(proposalSegment)) {
        continue;
      }
      double cost=0f;
      for (      DataSegment segment : server.getServer().getSegments().values()) {
        if (!proposalSegment.equals(segment)) {
          cost+=computeJointSegmentCosts(proposalSegment,segment);
        }
      }
      for (      DataSegment segment : server.getPeon().getSegmentsToLoad()) {
        cost+=computeJointSegmentCosts(proposalSegment,segment);
      }
      if (cost < bestServer.lhs) {
        bestServer=Pair.of(cost,server);
      }
    }
  }
  return bestServer;
}
