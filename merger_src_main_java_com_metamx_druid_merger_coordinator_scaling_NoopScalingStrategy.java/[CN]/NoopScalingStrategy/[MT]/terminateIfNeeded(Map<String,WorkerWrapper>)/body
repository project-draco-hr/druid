{
synchronized (lock) {
    if (currentlyTerminating != null) {
      if (zkWorkers.containsKey(currentlyTerminating)) {
        log.info("[%s] has not terminated. Wait for it to finish before terminating again.",currentlyTerminating);
        return null;
      }
    }
    MinMaxPriorityQueue<WorkerWrapper> currWorkers=MinMaxPriorityQueue.orderedBy(new Comparator<WorkerWrapper>(){
      @Override public int compare(      WorkerWrapper w1,      WorkerWrapper w2){
        DateTime w1Time=(w1 == null) ? new DateTime(0) : w1.getLastCompletedTaskTime();
        DateTime w2Time=(w2 == null) ? new DateTime(0) : w2.getLastCompletedTaskTime();
        return w1Time.compareTo(w2Time);
      }
    }
).create(zkWorkers.values());
    if (currWorkers.size() <= config.getMinNuMWorkers()) {
      return null;
    }
    WorkerWrapper thatLazyWorker=currWorkers.poll();
    if (System.currentTimeMillis() - thatLazyWorker.getLastCompletedTaskTime().getMillis() > config.getMillisToWaitBeforeTerminating()) {
      try {
        log.info("If I were a real strategy I'd terminate something now");
        currentlyTerminating="willNeverBeTrue";
        return null;
      }
 catch (      Exception e) {
        log.error(e,"Unable to terminate instance");
        currentlyTerminating=null;
      }
    }
    return null;
  }
}
