{
  log.info("Starting zkCoordinator for server[%s]",me);
synchronized (lock) {
    if (started) {
      return;
    }
    loadQueueCache=new PathChildrenCache(curator,loadQueueLocation,true,true,new ThreadFactoryBuilder().setDaemon(true).setNameFormat("ZkCoordinator-%s").build());
    try {
      config.getSegmentInfoCacheDirectory().mkdirs();
      curator.newNamespaceAwareEnsurePath(loadQueueLocation).ensure(curator.getZookeeperClient());
      curator.newNamespaceAwareEnsurePath(servedSegmentsLocation).ensure(curator.getZookeeperClient());
      loadCache();
      loadQueueCache.getListenable().addListener(new PathChildrenCacheListener(){
        @Override public void childEvent(        CuratorFramework client,        PathChildrenCacheEvent event) throws Exception {
          final ChildData child=event.getData();
switch (event.getType()) {
case CHILD_ADDED:
            final String path=child.getPath();
          final DataSegmentChangeRequest segment=jsonMapper.readValue(child.getData(),DataSegmentChangeRequest.class);
        log.info("New node[%s] with segmentClass[%s]",path,segment.getClass());
      try {
        segment.go(ZkCoordinator.this);
        curator.delete().guaranteed().forPath(path);
        log.info("Completed processing for node[%s]",path);
      }
 catch (      Exception e) {
        try {
          curator.delete().guaranteed().forPath(path);
        }
 catch (        Exception e1) {
          log.info(e1,"Failed to delete node[%s], but ignoring exception.",path);
        }
        log.makeAlert(e,"Segment load/unload: uncaught exception.").addData("node",path).addData("nodeProperties",segment).emit();
      }
    break;
case CHILD_REMOVED:
  log.info("%s was removed",event.getData().getPath());
break;
default :
log.info("Ignoring event[%s]",event);
}
}
}
);
loadQueueCache.start();
}
 catch (Exception e) {
Throwables.propagateIfPossible(e,IOException.class);
throw Throwables.propagate(e);
}
started=true;
}
}
