{
  Pair<Double,ServerHolder> bestServer=Pair.of(Double.POSITIVE_INFINITY,null);
  MinMaxPriorityQueue<Pair<Double,ServerHolder>> costsAndServers=MinMaxPriorityQueue.orderedBy(new Comparator<Pair<Double,ServerHolder>>(){
    @Override public int compare(    Pair<Double,ServerHolder> o,    Pair<Double,ServerHolder> o1){
      return Double.compare(o.lhs,o1.lhs);
    }
  }
).create();
  final long proposalSegmentSize=proposalSegment.getSize();
  for (  ServerHolder server : serverHolders) {
    if (proposalSegmentSize > server.getAvailableSize() || server.isLoadingSegment(proposalSegment)) {
      continue;
    }
    double cost=0f;
    for (    DataSegment segment : server.getServer().getSegments().values()) {
      if (!proposalSegment.equals(segment)) {
        cost+=computeJointSegmentCosts(proposalSegment,segment);
      }
    }
    for (    DataSegment segment : server.getPeon().getSegmentsToLoad()) {
      cost+=computeJointSegmentCosts(proposalSegment,segment);
    }
    if (cost < bestServer.lhs && !server.isServingSegment(proposalSegment)) {
      bestServer=Pair.of(cost,server);
    }
  }
  return bestServer;
}
