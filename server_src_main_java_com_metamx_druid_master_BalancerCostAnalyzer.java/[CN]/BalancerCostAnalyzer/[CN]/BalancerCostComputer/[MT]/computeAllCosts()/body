{
  MinMaxPriorityQueue<Pair<Double,ServerHolder>> costsServerHolderPairs=MinMaxPriorityQueue.orderedBy(new Comparator<Pair<Double,ServerHolder>>(){
    @Override public int compare(    Pair<Double,ServerHolder> o,    Pair<Double,ServerHolder> o1){
      return Double.compare(o.lhs,o1.lhs);
    }
  }
).create();
  for (  ServerHolder server : serverHolderList) {
    if (proposalSegment.getSize() > server.getAvailableSize()) {
      break;
    }
    double cost=0f;
    for (    DataSegment segment : server.getServer().getSegments().values()) {
      cost+=computeJointSegmentCosts(proposalSegment,segment);
    }
    if (!fromServerHolder.getServer().equals(server.getServer())) {
      cost+=computeJointSegmentCosts(proposalSegment,proposalSegment);
    }
    for (    BalancerSegmentHolder segmentToMove : segmentHoldersToMove) {
      if (server.getServer().equals(segmentToMove.getToServer())) {
        cost+=computeJointSegmentCosts(proposalSegment,segmentToMove.getSegment());
      }
      if (server.getServer().equals(segmentToMove.getFromServer())) {
        cost-=computeJointSegmentCosts(proposalSegment,segmentToMove.getSegment());
      }
    }
    if (fromServerHolder.getServer().equals(server.getServer())) {
      currCost=cost;
    }
    costsServerHolderPairs.add(Pair.of(cost,server));
  }
  minPair=costsServerHolderPairs.pollFirst();
}
