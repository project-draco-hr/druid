{
  return exec.submit(new Callable<TaskStatus>(){
    @Override public TaskStatus call(){
      final String attemptUUID=UUID.randomUUID().toString();
      final File taskDir=new File(config.getBaseTaskDir(),task.getId());
      final File attemptDir=new File(taskDir,attemptUUID);
      ProcessHolder processHolder=null;
      try {
        if (!attemptDir.mkdirs()) {
          throw new IOException(String.format("Could not create directories: %s",attemptDir));
        }
        final File taskFile=new File(attemptDir,"task.json");
        final File statusFile=new File(attemptDir,"status.json");
        final File logFile=new File(attemptDir,"log");
synchronized (processLock) {
          if (getProcessHolder(task.getId()).isPresent()) {
            throw new ISE("Task already running: %s",task.getId());
          }
          final List<String> command=Lists.newArrayList();
          final int childPort=findUnusedPort();
          final String childHost=String.format(config.getHostPattern(),childPort);
          Iterables.addAll(command,ImmutableList.of(config.getJavaCommand(),"-cp",config.getJavaClasspath()));
          Iterables.addAll(command,Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().split(config.getJavaOptions()));
          for (          String propName : System.getProperties().stringPropertyNames()) {
            if (propName.startsWith(CHILD_PROPERTY_PREFIX)) {
              command.add(String.format("-D%s=%s",propName.substring(CHILD_PROPERTY_PREFIX.length()),System.getProperty(propName)));
            }
          }
          command.add(String.format("-Ddruid.host=%s",childHost));
          command.add(String.format("-Ddruid.port=%d",childPort));
          command.add(config.getMainClass());
          command.add(taskFile.toString());
          command.add(statusFile.toString());
          jsonMapper.writeValue(taskFile,task);
          log.info("Running command: %s",Joiner.on(" ").join(command));
          processHolder=new ProcessHolder(task,new ProcessBuilder(ImmutableList.copyOf(command)).redirectErrorStream(true).start(),logFile,childPort);
          processes.add(processHolder);
        }
        log.info("Logging task %s output to: %s",task.getId(),logFile);
        final OutputStream toLogfile=Files.newOutputStreamSupplier(logFile).getOutput();
        final InputStream fromProc=processHolder.process.getInputStream();
        boolean copyFailed=false;
        try {
          ByteStreams.copy(fromProc,toLogfile);
        }
 catch (        Exception e) {
          log.warn(e,"Failed to read from process for task: %s",task.getId());
          copyFailed=true;
        }
 finally {
          Closeables.closeQuietly(fromProc);
          Closeables.closeQuietly(toLogfile);
        }
        final int statusCode=processHolder.process.waitFor();
        log.info("Process exited with status[%d] for task: %s",statusCode,task.getId());
        taskLogPusher.pushTaskLog(task.getId(),logFile);
        if (!copyFailed && statusCode == 0) {
          return jsonMapper.readValue(statusFile,TaskStatus.class);
        }
 else {
          return TaskStatus.failure(task.getId());
        }
      }
 catch (      InterruptedException e) {
        log.info(e,"Interrupted while waiting for process!");
        return TaskStatus.failure(task.getId());
      }
catch (      IOException e) {
        throw Throwables.propagate(e);
      }
 finally {
        try {
          if (processHolder != null) {
synchronized (processLock) {
              processes.remove(processHolder);
            }
          }
          log.info("Removing temporary directory: %s",attemptDir);
          FileUtils.deleteDirectory(attemptDir);
        }
 catch (        Exception e) {
          log.error(e,"Failed to delete temporary directory");
        }
      }
    }
  }
);
}
