{
  final CountingMap<String> droppedCounts=new CountingMap<String>();
  int deletedCount=0;
  Set<DataSegment> availableSegments=params.getAvailableSegments();
  DruidCluster cluster=params.getDruidCluster();
  for (  MinMaxPriorityQueue<ServerHolder> serverHolders : cluster.getSortedServersByTier()) {
    for (    ServerHolder serverHolder : serverHolders) {
      DruidServer server=serverHolder.getServer();
      for (      DruidDataSource dataSource : server.getDataSources()) {
        for (        DataSegment segment : dataSource.getSegments()) {
          if (!availableSegments.contains(segment)) {
            LoadQueuePeon queuePeon=params.getLoadManagementPeons().get(server.getName());
            if (!queuePeon.getSegmentsToDrop().contains(segment)) {
              queuePeon.dropSegment(segment,new LoadPeonCallback(){
                @Override protected void execute(){
                }
              }
);
              droppedCounts.add(server.getTier(),1);
            }
          }
        }
      }
    }
  }
  if (System.currentTimeMillis() - params.getStartTime() > params.getMillisToWaitBeforeDeleting()) {
    Map<String,VersionedIntervalTimeline<String,DataSegment>> timelines=Maps.newHashMap();
    for (    MinMaxPriorityQueue<ServerHolder> serverHolders : cluster.getSortedServersByTier()) {
      for (      ServerHolder serverHolder : serverHolders) {
        DruidServer server=serverHolder.getServer();
        for (        DruidDataSource dataSource : server.getDataSources()) {
          VersionedIntervalTimeline<String,DataSegment> timeline=timelines.get(dataSource.getName());
          if (timeline == null) {
            timeline=new VersionedIntervalTimeline<String,DataSegment>(Comparators.comparable());
            timelines.put(dataSource.getName(),timeline);
          }
          for (          DataSegment segment : dataSource.getSegments()) {
            timeline.add(segment.getInterval(),segment.getVersion(),segment.getShardSpec().createChunk(segment));
          }
        }
      }
    }
    for (    VersionedIntervalTimeline<String,DataSegment> timeline : timelines.values()) {
      for (      TimelineObjectHolder<String,DataSegment> holder : timeline.findOvershadowed()) {
        for (        DataSegment dataSegment : holder.getObject().payloads()) {
          log.info("Deleting[%s].",dataSegment);
          master.removeSegment(dataSegment);
          ++deletedCount;
        }
      }
    }
    for (    DataSegment segment : availableSegments) {
      Rule rule=params.getSegmentRuleLookup().lookup(segment.getIdentifier());
      DropStat stat=rule.runDrop(master,params,segment);
      deletedCount+=stat.getDeletedCount();
      if (stat.getDroppedCount() != null) {
        droppedCounts.putAll(stat.getDroppedCount());
      }
    }
  }
  List<String> dropMsgs=Lists.newArrayList();
  for (  Map.Entry<String,AtomicLong> entry : droppedCounts.entrySet()) {
    dropMsgs.add(String.format("[%s] : Dropped %s segments among %,d servers",entry.getKey(),droppedCounts.get(entry.getKey()),cluster.get(entry.getKey()).size()));
  }
  return params.buildFromExisting().withMessages(dropMsgs).withMessage(String.format("Deleted %,d segments",deletedCount)).withDroppedCount(droppedCounts).withDeletedCount(deletedCount).build();
}
