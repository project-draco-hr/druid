{
  Set<DataSegment> availableSegments=params.getAvailableSegments();
  Collection<DruidServer> servicedData=params.getHistoricalServers();
  int droppedCount=0;
  int deletedCount=0;
  for (  DruidServer server : servicedData) {
    for (    DruidDataSource dataSource : server.getDataSources()) {
      for (      DataSegment segment : dataSource.getSegments()) {
        if (!availableSegments.contains(segment)) {
          LoadQueuePeon queuePeon=params.getLoadManagementPeons().get(server.getName());
          if (!queuePeon.getSegmentsToDrop().contains(segment)) {
            queuePeon.dropSegment(segment,new LoadPeonCallback(){
              @Override protected void execute(){
                return;
              }
            }
);
            ++droppedCount;
          }
        }
      }
    }
  }
  if (System.currentTimeMillis() - params.getStartTime() > params.getMillisToWaitBeforeDeleting()) {
    Map<String,VersionedIntervalTimeline<String,DataSegment>> timelines=Maps.newHashMap();
    for (    DruidServer server : servicedData) {
      for (      DruidDataSource dataSource : server.getDataSources()) {
        VersionedIntervalTimeline<String,DataSegment> timeline=timelines.get(dataSource.getName());
        if (timeline == null) {
          timeline=new VersionedIntervalTimeline<String,DataSegment>(Comparators.comparable());
          timelines.put(dataSource.getName(),timeline);
        }
        for (        DataSegment segment : dataSource.getSegments()) {
          timeline.add(segment.getInterval(),segment.getVersion(),segment.getShardSpec().createChunk(segment));
        }
      }
    }
    for (    VersionedIntervalTimeline<String,DataSegment> timeline : timelines.values()) {
      for (      TimelineObjectHolder<String,DataSegment> holder : timeline.findOvershadowed()) {
        for (        DataSegment dataSegment : holder.getObject().payloads()) {
          log.info("Deleting[%s].",dataSegment);
          removeSegment(dataSegment);
          ++deletedCount;
        }
      }
    }
  }
  return params.buildFromExisting().withMessage(String.format("Dropped %,d segments from %,d servers",droppedCount,servicedData.size())).withMessage(String.format("Deleted %,d segments",deletedCount)).withDroppedCount(droppedCount).withDeletedCount(deletedCount).build();
}
