{
  final QueryRunnerFactory<T,Query<T>> factory=conglomerate.findFactory(query);
  if (factory == null) {
    throw new ISE("Unknown query type[%s].",query.getClass());
  }
  final QueryToolChest<T,Query<T>> toolChest=factory.getToolchest();
  final VersionedIntervalTimeline<String,ReferenceCountingSegment> timeline=dataSources.get(query.getDataSource());
  if (timeline == null) {
    return new NoopQueryRunner<T>();
  }
  FunctionalIterable<QueryRunner<T>> adapters=FunctionalIterable.create(intervals).transformCat(new Function<Interval,Iterable<TimelineObjectHolder<String,ReferenceCountingSegment>>>(){
    @Override public Iterable<TimelineObjectHolder<String,ReferenceCountingSegment>> apply(    Interval input){
      return timeline.lookup(input);
    }
  }
).transformCat(new Function<TimelineObjectHolder<String,ReferenceCountingSegment>,Iterable<QueryRunner<T>>>(){
    @Override public Iterable<QueryRunner<T>> apply(    @Nullable final TimelineObjectHolder<String,ReferenceCountingSegment> holder){
      if (holder == null) {
        return null;
      }
      return FunctionalIterable.create(holder.getObject()).transform(new Function<PartitionChunk<ReferenceCountingSegment>,QueryRunner<T>>(){
        @Override public QueryRunner<T> apply(        PartitionChunk<ReferenceCountingSegment> input){
          return buildAndDecorateQueryRunner(factory,toolChest,input.getObject(),new SpecificSegmentSpec(new SegmentDescriptor(holder.getInterval(),holder.getVersion(),input.getChunkNumber())));
        }
      }
).filter(Predicates.<QueryRunner<T>>notNull());
    }
  }
).filter(Predicates.<QueryRunner<T>>notNull());
  return new FinalizeResultsQueryRunner<T>(toolChest.mergeResults(factory.mergeRunners(exec,adapters)),toolChest);
}
