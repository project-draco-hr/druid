{
  final QueryRunnerFactory<T,Query<T>> factory=conglomerate.findFactory(query);
  if (factory == null) {
    throw new ISE("Unknown query type[%s].",query.getClass());
  }
  final QueryToolChest<T,Query<T>> toolChest=factory.getToolchest();
  final VersionedIntervalTimeline<String,StorageAdapter> timeline=dataSources.get(query.getDataSource());
  if (timeline == null) {
    return new NoopQueryRunner<T>();
  }
  FunctionalIterable<QueryRunner<T>> adapters=FunctionalIterable.create(intervals).transformCat(new Function<Interval,Iterable<TimelineObjectHolder<String,StorageAdapter>>>(){
    @Override public Iterable<TimelineObjectHolder<String,StorageAdapter>> apply(    Interval input){
      return timeline.lookup(input);
    }
  }
).transformCat(new Function<TimelineObjectHolder<String,StorageAdapter>,Iterable<QueryRunner<T>>>(){
    @Override public Iterable<QueryRunner<T>> apply(    @Nullable final TimelineObjectHolder<String,StorageAdapter> holder){
      if (holder == null) {
        return null;
      }
      return FunctionalIterable.create(holder.getObject()).transform(new Function<PartitionChunk<StorageAdapter>,QueryRunner<T>>(){
        @Override public QueryRunner<T> apply(        PartitionChunk<StorageAdapter> input){
          return buildAndDecorateQueryRunner(factory,toolChest,input.getObject(),new SpecificSegmentSpec(new SegmentDescriptor(holder.getInterval(),holder.getVersion(),input.getChunkNumber())));
        }
      }
);
    }
  }
);
  return new FinalizeResultsQueryRunner<T>(toolChest.mergeResults(factory.mergeRunners(exec,adapters)),toolChest);
}
