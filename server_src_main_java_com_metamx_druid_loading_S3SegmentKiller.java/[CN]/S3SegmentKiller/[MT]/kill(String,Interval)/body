{
  List<DataSegment> matchingSegments=dbi.withHandle(new HandleCallback<List<DataSegment>>(){
    @Override public List<DataSegment> withHandle(    Handle handle) throws Exception {
      return handle.createQuery(String.format("SELECT payload FROM %s WHERE dataSource = :dataSource and start >= :start and end <= :end and used = 0",config.getSegmentTable())).bind("dataSource",datasource).bind("start",interval.getStart().toString()).bind("end",interval.getEnd().toString()).fold(Lists.<DataSegment>newArrayList(),new Folder3<List<DataSegment>,Map<String,Object>>(){
        @Override public List<DataSegment> fold(        List<DataSegment> accumulator,        Map<String,Object> stringObjectMap,        FoldController foldController,        StatementContext statementContext) throws SQLException {
          try {
            DataSegment segment=jsonMapper.readValue((String)stringObjectMap.get("payload"),DataSegment.class);
            accumulator.add(segment);
            return accumulator;
          }
 catch (          Exception e) {
            throw Throwables.propagate(e);
          }
        }
      }
);
    }
  }
);
  log.info("Found %,d segments for %s for interval %s.",matchingSegments.size(),datasource,interval);
  for (  final DataSegment segment : matchingSegments) {
    Map<String,Object> loadSpec=segment.getLoadSpec();
    String s3Bucket=MapUtils.getString(loadSpec,"bucket");
    String s3Path=MapUtils.getString(loadSpec,"key");
    String s3DescriptorPath=s3Path.substring(0,s3Path.lastIndexOf("/")) + "/descriptor.json";
    if (s3Client.isObjectInBucket(s3Bucket,s3Path)) {
      log.info("Removing index file[s3://%s/%s] from s3!",s3Bucket,s3Path);
      s3Client.deleteObject(s3Bucket,s3Path);
    }
    if (s3Client.isObjectInBucket(s3Bucket,s3DescriptorPath)) {
      log.info("Removing descriptor file[s3://%s/%s] from s3!",s3Bucket,s3DescriptorPath);
      s3Client.deleteObject(s3Bucket,s3DescriptorPath);
    }
  }
  return matchingSegments;
}
