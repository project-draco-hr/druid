{
  log.info("Determining partitions for interval[%s] with targetPartitionSize[%d]",interval,targetPartitionSize);
  final FirehoseFactory firehoseFactory=ingestionSchema.getIOConfig().getFirehoseFactory();
  final Set<String> unusableDimensions=com.google.common.collect.Sets.newHashSet();
  final Map<String,TreeMultiset<String>> dimensionValueMultisets=Maps.newHashMap();
  try (Firehose firehose=firehoseFactory.connect(ingestionSchema.getDataSchema().getParser())){
    while (firehose.hasMore()) {
      final InputRow inputRow=firehose.nextRow();
      if (interval.contains(inputRow.getTimestampFromEpoch())) {
        for (        final String dim : inputRow.getDimensions()) {
          final List<String> dimValues=inputRow.getDimension(dim);
          if (!unusableDimensions.contains(dim)) {
            if (dimValues.size() == 1) {
              TreeMultiset<String> dimensionValueMultiset=dimensionValueMultisets.get(dim);
              if (dimensionValueMultiset == null) {
                dimensionValueMultiset=TreeMultiset.create();
                dimensionValueMultisets.put(dim,dimensionValueMultiset);
              }
              dimensionValueMultiset.add(dimValues.get(0));
            }
 else {
              unusableDimensions.add(dim);
              dimensionValueMultisets.remove(dim);
            }
          }
        }
      }
    }
  }
   final List<ShardSpec> shardSpecs=Lists.newArrayList();
  Ordering<Map.Entry<String,TreeMultiset<String>>> byCardinalityOrdering=new Ordering<Map.Entry<String,TreeMultiset<String>>>(){
    @Override public int compare(    Map.Entry<String,TreeMultiset<String>> left,    Map.Entry<String,TreeMultiset<String>> right){
      return Ints.compare(left.getValue().elementSet().size(),right.getValue().elementSet().size());
    }
  }
;
  if (dimensionValueMultisets.isEmpty()) {
    log.info("No suitable partition dimension found");
    shardSpecs.add(new NoneShardSpec());
  }
 else {
    final Map.Entry<String,TreeMultiset<String>> partitionEntry=byCardinalityOrdering.max(dimensionValueMultisets.entrySet());
    final String partitionDim=partitionEntry.getKey();
    final TreeMultiset<String> partitionDimValues=partitionEntry.getValue();
    log.info("Partitioning on dimension[%s] with cardinality[%d] over rows[%d]",partitionDim,partitionDimValues.elementSet().size(),partitionDimValues.size());
    String currentPartitionStart=null;
    int currentPartitionSize=0;
    for (    final String partitionDimValue : partitionDimValues.elementSet()) {
      currentPartitionSize+=partitionDimValues.count(partitionDimValue);
      if (currentPartitionSize >= targetPartitionSize) {
        final ShardSpec shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,partitionDimValue,shardSpecs.size());
        log.info("Adding shard: %s",shardSpec);
        shardSpecs.add(shardSpec);
        currentPartitionSize=partitionDimValues.count(partitionDimValue);
        currentPartitionStart=partitionDimValue;
      }
    }
    if (currentPartitionSize > 0) {
      final ShardSpec shardSpec;
      if (shardSpecs.isEmpty()) {
        shardSpec=new NoneShardSpec();
      }
 else {
        shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,null,shardSpecs.size());
      }
      log.info("Adding shard: %s",shardSpec);
      shardSpecs.add(shardSpec);
    }
  }
  return shardSpecs;
}
