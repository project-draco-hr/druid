{
  final List<ShardSpec> shardSpecs=Lists.newArrayList();
  Ordering<Map.Entry<String,TreeMultiset<String>>> byCardinalityOrdering=new Ordering<Map.Entry<String,TreeMultiset<String>>>(){
    @Override public int compare(    Map.Entry<String,TreeMultiset<String>> left,    Map.Entry<String,TreeMultiset<String>> right){
      return Ints.compare(left.getValue().elementSet().size(),right.getValue().elementSet().size());
    }
  }
;
  if (dimensionValueMultisets.isEmpty()) {
    log.info("No suitable partition dimension found");
    shardSpecs.add(new NoneShardSpec());
  }
 else {
    final Map.Entry<String,TreeMultiset<String>> partitionEntry=byCardinalityOrdering.max(dimensionValueMultisets.entrySet());
    final String partitionDim=partitionEntry.getKey();
    final TreeMultiset<String> partitionDimValues=partitionEntry.getValue();
    log.info("Partitioning on dimension[%s] with cardinality[%d] over rows[%d]",partitionDim,partitionDimValues.elementSet().size(),partitionDimValues.size());
    String currentPartitionStart=null;
    int currentPartitionSize=0;
    for (    final String partitionDimValue : partitionDimValues.elementSet()) {
      currentPartitionSize+=partitionDimValues.count(partitionDimValue);
      if (currentPartitionSize >= targetPartitionSize) {
        final ShardSpec shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,partitionDimValue,shardSpecs.size());
        log.info("Adding shard: %s",shardSpec);
        shardSpecs.add(shardSpec);
        currentPartitionSize=partitionDimValues.count(partitionDimValue);
        currentPartitionStart=partitionDimValue;
      }
    }
    if (currentPartitionSize > 0) {
      final ShardSpec shardSpec;
      if (shardSpecs.isEmpty()) {
        shardSpec=new NoneShardSpec();
      }
 else {
        shardSpec=new SingleDimensionShardSpec(partitionDim,currentPartitionStart,null,shardSpecs.size());
      }
      log.info("Adding shard: %s",shardSpec);
      shardSpecs.add(shardSpec);
    }
  }
  return shardSpecs;
}
