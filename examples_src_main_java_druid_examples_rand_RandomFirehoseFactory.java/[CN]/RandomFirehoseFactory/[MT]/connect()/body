{
  final LinkedList<String> dimensions=new LinkedList<String>();
  dimensions.add("inColumn");
  dimensions.add("target");
  return new Firehose(){
    private final java.util.Random rand=(seed == 0L) ? new Random() : new Random(seed);
    private long rowCount=0L;
    private boolean waitIfmaxGeneratedRows=true;
    @Override public boolean hasMore(){
      if (maxGeneratedRows >= 0 && rowCount >= maxGeneratedRows) {
        return waitIfmaxGeneratedRows;
      }
 else {
        return true;
      }
    }
    @Override public InputRow nextRow(){
      final long modulus=rowCount % nPerSleep;
      final long nth=(rowCount % nTokens) + 1;
      long sleepMsec=delayMsec;
      if (maxGeneratedRows >= 0 && rowCount >= maxGeneratedRows && waitIfmaxGeneratedRows) {
        sleepMsec=2000000000L;
      }
      if (sleepMsec > 0L || delayNsec > 0) {
        try {
          if (modulus == 0) {
            sleep(sleepMsec,delayNsec);
          }
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("InterruptedException");
        }
      }
      if (++rowCount % 1000 == 0) {
        log.info("%,d events created.",rowCount);
      }
      final Map<String,Object> theMap=Maps.newTreeMap(String.CASE_INSENSITIVE_ORDER);
      theMap.put("inColumn",anotherRand((int)nth));
      theMap.put("target",("a" + nth));
      return new MapBasedInputRow(System.currentTimeMillis(),dimensions,theMap);
    }
    private Float anotherRand(    int scale){
      double f=rand.nextDouble();
      return new Float(f + (double)scale);
    }
    @Override public Runnable commit(){
      return new Runnable(){
        @Override public void run(){
        }
      }
;
    }
    @Override public void close() throws IOException {
    }
  }
;
}
