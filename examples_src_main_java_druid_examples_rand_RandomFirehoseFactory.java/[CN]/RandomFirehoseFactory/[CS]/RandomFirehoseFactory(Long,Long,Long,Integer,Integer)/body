{
  long nsec=(sleepUsec > 0) ? sleepUsec * 1000L : 0;
  long msec=nsec / 1000000L;
  this.delayMsec=msec;
  this.delayNsec=(int)(nsec - (msec * 1000000L));
  this.maxGeneratedRows=maxGeneratedRows;
  this.seed=seed;
  this.nTokens=nTokens;
  this.nPerSleep=nPerSleep;
  if (nTokens <= 0) {
    log.warn("nTokens parameter " + nTokens + " ignored; must be greater than or equal to 1");
    nTokens=1;
  }
  if (nPerSleep <= 0) {
    log.warn("nPerSleep parameter " + nPerSleep + " ignored; must be greater than or equal to 1");
    nPerSleep=1;
  }
  log.info("maxGeneratedRows=" + maxGeneratedRows);
  log.info("seed=" + ((seed == 0L) ? "random value" : seed));
  log.info("nTokens=" + nTokens);
  log.info("nPerSleep=" + nPerSleep);
  double dmsec=(double)delayMsec + ((double)this.delayNsec) / 1000000.;
  if (dmsec > 0.0) {
    log.info("sleep period=" + dmsec + "msec");
    log.info("approximate max rate of record generation=" + (nPerSleep * 1000. / dmsec) + "/sec"+ "  or  "+ (60. * nPerSleep * 1000. / dmsec)+ "/minute");
  }
 else {
    log.info("sleep period= NONE");
    log.info("approximate max rate of record generation= as fast as possible");
  }
}
