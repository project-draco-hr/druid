{
  ExecutorService exec=PrioritizedExecutorService.create(new Lifecycle(),new ExecutorServiceConfig(){
    @Override public String getFormatString(){
      return "test";
    }
    @Override public int getNumThreads(){
      return 2;
    }
  }
);
  final CountDownLatch queriesStarted=new CountDownLatch(2);
  final CountDownLatch queryIsRegistered=new CountDownLatch(1);
  final Map<Query,ListenableFuture> queries=Maps.newHashMap();
  QueryWatcher watcher=new QueryWatcher(){
    @Override public void registerQuery(    Query query,    ListenableFuture future){
      queries.put(query,future);
      queryIsRegistered.countDown();
    }
  }
;
  ChainedExecutionQueryRunner chainedRunner=new ChainedExecutionQueryRunner<>(exec,Ordering.<Integer>natural(),watcher,Lists.<QueryRunner<Integer>>newArrayList(new DyingQueryRunner(1,queriesStarted),new DyingQueryRunner(2,queriesStarted),new DyingQueryRunner(3,queriesStarted)));
  final Sequence seq=chainedRunner.run(Druids.newTimeseriesQueryBuilder().dataSource("test").intervals("2014/2015").aggregators(Lists.<AggregatorFactory>newArrayList(new CountAggregatorFactory("count"))).build());
  Future f=Executors.newFixedThreadPool(1).submit(new Runnable(){
    @Override public void run(){
      Sequences.toList(seq,Lists.newArrayList());
    }
  }
);
  queryIsRegistered.await();
  queriesStarted.await();
  queries.values().iterator().next().cancel(true);
  f.get();
}
