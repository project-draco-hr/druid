{
  WorkerCuratorCoordinator workerCuratorCoordinator=new WorkerCuratorCoordinator(jsonMapper,new IndexerZkConfig(){
    @Override public String getAnnouncementPath(){
      return announcementsPath;
    }
    @Override public String getTaskPath(){
      return tasksPath;
    }
    @Override public String getStatusPath(){
      return statusPath;
    }
  }
,cf,worker1);
  workerCuratorCoordinator.start();
  taskMonitor=new TaskMonitor(new PathChildrenCache(cf,String.format("%s/worker1",tasksPath),true),cf,workerCuratorCoordinator,new TaskToolbox(new IndexerCoordinatorConfig(){
    @Override public String getServerName(){
      return "worker1";
    }
    @Override public String getLeaderLatchPath(){
      return null;
    }
    @Override public int getNumLocalThreads(){
      return 1;
    }
    @Override public String getRunnerImpl(){
      return null;
    }
    @Override public String getStorageImpl(){
      return null;
    }
    @Override public File getBaseTaskDir(){
      try {
        return File.createTempFile("billy","yay");
      }
 catch (      Exception e) {
        throw Throwables.propagate(e);
      }
    }
    @Override public boolean isWhitelistEnabled(){
      return false;
    }
    @Override public String getWhitelistDatasourcesString(){
      return null;
    }
    @Override public long getRowFlushBoundary(){
      return 0;
    }
  }
,null,null,null,jsonMapper),Executors.newSingleThreadExecutor());
  jsonMapper.registerSubtypes(new NamedType(TestTask.class,"test"));
  taskMonitor.start();
}
