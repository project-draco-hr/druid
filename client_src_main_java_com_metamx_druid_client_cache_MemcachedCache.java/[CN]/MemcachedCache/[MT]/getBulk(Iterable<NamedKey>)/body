{
  Map<String,NamedKey> keyLookup=Maps.uniqueIndex(keys,new Function<NamedKey,String>(){
    @Override public String apply(    @Nullable NamedKey input){
      return computeKeyHash(memcachedPrefix,input);
    }
  }
);
  BulkFuture<Map<String,Object>> future=client.asyncGetBulk(keyLookup.keySet());
  try {
    Map<String,Object> some=future.getSome(timeout,TimeUnit.MILLISECONDS);
    if (future.isTimeout()) {
      future.cancel(false);
      timeoutCount.incrementAndGet();
    }
    missCount.addAndGet(keyLookup.size() - some.size());
    hitCount.addAndGet(some.size());
    Map<NamedKey,byte[]> results=Maps.newHashMap();
    for (    Map.Entry<String,Object> entry : some.entrySet()) {
      final NamedKey key=keyLookup.get(entry.getKey());
      final byte[] value=(byte[])entry.getValue();
      results.put(key,value == null ? null : deserializeValue(key,value));
    }
    return results;
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw Throwables.propagate(e);
  }
catch (  ExecutionException e) {
    throw Throwables.propagate(e);
  }
}
