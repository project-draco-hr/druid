{
  List<String> workerNodeIds=autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(zkWorkers,new Function<ZkWorker,String>(){
    @Override public String apply(    ZkWorker input){
      return input.getWorker().getIp();
    }
  }
)));
  for (  String workerNodeId : workerNodeIds) {
    currentlyTerminating.remove(workerNodeId);
  }
  boolean nothingTerminating=currentlyTerminating.isEmpty();
  if (nothingTerminating) {
    final int minNumWorkers=workerSetupManager.getWorkerSetupData().getMinNumWorkers();
    if (zkWorkers.size() <= minNumWorkers) {
      return false;
    }
    List<ZkWorker> thoseLazyWorkers=Lists.newArrayList(FunctionalIterable.create(zkWorkers).filter(new Predicate<ZkWorker>(){
      @Override public boolean apply(      ZkWorker input){
        return input.getRunningTasks().isEmpty() && System.currentTimeMillis() - input.getLastCompletedTaskTime().getMillis() >= config.getMaxWorkerIdleTimeMillisBeforeDeletion();
      }
    }
));
    if (thoseLazyWorkers.size() <= minNumWorkers) {
      return false;
    }
    AutoScalingData terminated=autoScalingStrategy.terminate(Lists.transform(thoseLazyWorkers.subList(minNumWorkers,thoseLazyWorkers.size() - 1),new Function<ZkWorker,String>(){
      @Override public String apply(      ZkWorker input){
        return input.getWorker().getIp();
      }
    }
));
    if (terminated != null) {
      currentlyTerminating.addAll(terminated.getNodeIds());
      lastTerminateTime=new DateTime();
      scalingStats.addTerminateEvent(terminated);
      return true;
    }
  }
 else {
    Duration durSinceLastTerminate=new Duration(new DateTime(),lastTerminateTime);
    if (durSinceLastTerminate.isLongerThan(config.getMaxScalingDuration())) {
      log.makeAlert("Worker node termination taking too long").addData("millisSinceLastTerminate",durSinceLastTerminate.getMillis()).addData("terminatingCount",currentlyTerminating.size()).emit();
    }
    log.info("%s still terminating. Wait for all nodes to terminate before trying again.",currentlyTerminating);
  }
  return false;
}
