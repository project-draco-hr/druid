{
  boolean nothingTerminating=Sets.difference(currentlyTerminating,Sets.newHashSet(autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(workerWrappers,new Function<WorkerWrapper,String>(){
    @Override public String apply(    WorkerWrapper input){
      return input.getWorker().getIp();
    }
  }
))))).isEmpty();
  if (nothingTerminating) {
    final int minNumWorkers=workerSetupManager.getWorkerSetupData().getMinNumWorkers();
    if (workerWrappers.size() <= minNumWorkers) {
      return;
    }
    List<WorkerWrapper> thoseLazyWorkers=Lists.newArrayList(FunctionalIterable.create(workerWrappers).filter(new Predicate<WorkerWrapper>(){
      @Override public boolean apply(      WorkerWrapper input){
        return input.getRunningTasks().isEmpty() && System.currentTimeMillis() - input.getLastCompletedTaskTime().getMillis() > config.getMaxWorkerIdleTimeMillisBeforeDeletion();
      }
    }
));
    AutoScalingData terminated=autoScalingStrategy.terminate(Lists.transform(thoseLazyWorkers.subList(minNumWorkers,thoseLazyWorkers.size() - 1),new Function<WorkerWrapper,String>(){
      @Override public String apply(      WorkerWrapper input){
        return input.getWorker().getIp();
      }
    }
));
    if (terminated != null) {
      currentlyTerminating.addAll(terminated.getNodeIds());
      lastTerminateTime=new DateTime();
      scalingStats.addProvisionEvent(terminated);
    }
  }
 else {
    Duration durSinceLastTerminate=new Duration(new DateTime(),lastTerminateTime);
    if (durSinceLastTerminate.isLongerThan(config.getMaxScalingDuration())) {
      log.makeAlert("Worker node termination taking too long").addData("millisSinceLastTerminate",durSinceLastTerminate.getMillis()).addData("terminatingCount",currentlyTerminating.size()).emit();
    }
    log.info("%s still terminating. Wait for all nodes to terminate before trying again.",currentlyTerminating);
  }
}
