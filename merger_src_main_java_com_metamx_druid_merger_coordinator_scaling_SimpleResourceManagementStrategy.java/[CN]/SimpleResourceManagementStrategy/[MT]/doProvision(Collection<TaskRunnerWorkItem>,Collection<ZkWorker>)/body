{
  List<String> workerNodeIds=autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(zkWorkers,new Function<ZkWorker,String>(){
    @Override public String apply(    ZkWorker input){
      return input.getWorker().getIp();
    }
  }
)));
  for (  String workerNodeId : workerNodeIds) {
    currentlyProvisioning.remove(workerNodeId);
  }
  boolean nothingProvisioning=currentlyProvisioning.isEmpty();
  if (nothingProvisioning) {
    if (hasTaskPendingBeyondThreshold(pendingTasks)) {
      AutoScalingData provisioned=autoScalingStrategy.provision();
      if (provisioned != null) {
        currentlyProvisioning.addAll(provisioned.getNodeIds());
        lastProvisionTime=new DateTime();
        scalingStats.addProvisionEvent(provisioned);
        return true;
      }
    }
  }
 else {
    Duration durSinceLastProvision=new Duration(new DateTime(),lastProvisionTime);
    if (durSinceLastProvision.isLongerThan(config.getMaxScalingDuration())) {
      log.makeAlert("Worker node provisioning taking too long").addData("millisSinceLastProvision",durSinceLastProvision.getMillis()).addData("provisioningCount",currentlyProvisioning.size()).emit();
    }
    log.info("%s still provisioning. Wait for all provisioned nodes to complete before requesting new worker.",currentlyProvisioning);
  }
  return false;
}
