{
  if (zkWorkers.size() >= workerSetupdDataRef.get().getMaxNumWorkers()) {
    log.info("Cannot scale anymore. Num workers = %d, Max num workers = %d",zkWorkers.size(),workerSetupdDataRef.get().getMaxNumWorkers());
    return false;
  }
  List<String> workerNodeIds=autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(zkWorkers,new Function<ZkWorker,String>(){
    @Override public String apply(    ZkWorker input){
      return input.getWorker().getIp();
    }
  }
)));
  currentlyProvisioning.removeAll(workerNodeIds);
  boolean nothingProvisioning=currentlyProvisioning.isEmpty();
  if (nothingProvisioning) {
    if (hasTaskPendingBeyondThreshold(pendingTasks)) {
      AutoScalingData provisioned=autoScalingStrategy.provision();
      if (provisioned != null) {
        currentlyProvisioning.addAll(provisioned.getNodeIds());
        lastProvisionTime=new DateTime();
        scalingStats.addProvisionEvent(provisioned);
        return true;
      }
    }
  }
 else {
    Duration durSinceLastProvision=new Duration(lastProvisionTime,new DateTime());
    log.info("%s still provisioning. Wait for all provisioned nodes to complete before requesting new worker. Current wait time: %s",currentlyProvisioning,durSinceLastProvision);
    if (durSinceLastProvision.isLongerThan(config.getMaxScalingDuration())) {
      log.makeAlert("Worker node provisioning taking too long!").addData("millisSinceLastProvision",durSinceLastProvision.getMillis()).addData("provisioningCount",currentlyProvisioning.size()).emit();
      List<String> nodeIps=autoScalingStrategy.idToIpLookup(Lists.newArrayList(currentlyProvisioning));
      autoScalingStrategy.terminate(nodeIps);
      currentlyProvisioning.clear();
    }
  }
  return false;
}
