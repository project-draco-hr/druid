{
  final String threadName=String.format("%s-%s-persist-n-merge",schema.getDataSource(),new DateTime(truncatedTime));
  mergeExecutor.execute(new ThreadRenamingRunnable(threadName){
    @Override public void doRun(){
      final Interval interval=sink.getInterval();
      final File persistDir=computePersistDir(schema,interval);
      final File mergedTarget=new File(persistDir,"merged");
      final File isPushedMarker=new File(persistDir,"isPushedMarker");
      if (!isPushedMarker.exists()) {
        removeSegment(sink,mergedTarget);
      }
 else {
        log.info("Skipping already-merged sink: %s",sink);
        return;
      }
      for (      FireHydrant hydrant : sink) {
synchronized (hydrant) {
          if (!hydrant.hasSwapped()) {
            log.info("Hydrant[%s] hasn't swapped yet, swapping. Sink[%s]",hydrant,sink);
            final int rowCount=persistHydrant(hydrant,schema,interval);
            metrics.incrementRowOutputCount(rowCount);
          }
        }
      }
      try {
        List<QueryableIndex> indexes=Lists.newArrayList();
        for (        FireHydrant fireHydrant : sink) {
          Segment segment=fireHydrant.getSegment();
          final QueryableIndex queryableIndex=segment.asQueryableIndex();
          log.info("Adding hydrant[%s]",fireHydrant);
          indexes.add(queryableIndex);
        }
        final File mergedFile=IndexMerger.mergeQueryableIndex(indexes,schema.getAggregators(),mergedTarget);
        QueryableIndex index=IndexIO.loadIndex(mergedFile);
        DataSegment segment=dataSegmentPusher.push(mergedFile,sink.getSegment().withDimensions(Lists.newArrayList(index.getAvailableDimensions())));
        segmentPublisher.publishSegment(segment);
        if (!isPushedMarker.createNewFile()) {
          log.makeAlert("Unable to make marker file! WTF?!").addData("marker",isPushedMarker).emit();
        }
      }
 catch (      Exception e) {
        log.makeAlert(e,"Failed to persist merged index[%s]",schema.getDataSource()).addData("interval",interval).emit();
        if (shuttingDown) {
          abandonSegment(truncatedTime,sink);
        }
      }
    }
  }
);
}
