{
  final boolean skipIncrementalSegment=query.getContextValue(SKIP_INCREMENTAL_SEGMENT,false);
  final QueryRunnerFactory<T,Query<T>> factory=conglomerate.findFactory(query);
  final QueryToolChest<T,Query<T>> toolchest=factory.getToolchest();
  final Function<Query<T>,ServiceMetricEvent.Builder> builderFn=new Function<Query<T>,ServiceMetricEvent.Builder>(){
    @Override public ServiceMetricEvent.Builder apply(    @Nullable Query<T> input){
      return toolchest.makeMetricBuilder(query);
    }
  }
;
  List<TimelineObjectHolder<String,Sink>> querySinks=Lists.newArrayList();
  for (  Interval interval : query.getIntervals()) {
    querySinks.addAll(sinkTimeline.lookup(interval));
  }
  return toolchest.mergeResults(factory.mergeRunners(queryExecutorService,FunctionalIterable.create(querySinks).transform(new Function<TimelineObjectHolder<String,Sink>,QueryRunner<T>>(){
    @Override public QueryRunner<T> apply(    TimelineObjectHolder<String,Sink> holder){
      if (holder == null) {
        throw new ISE("No timeline entry at all!");
      }
      final Sink theSink=holder.getObject().getChunk(0).getObject();
      if (theSink == null) {
        throw new ISE("Missing sink for timeline entry[%s]!",holder);
      }
      final SegmentDescriptor descriptor=new SegmentDescriptor(holder.getInterval(),theSink.getSegment().getVersion(),theSink.getSegment().getShardSpec().getPartitionNum());
      return new SpecificSegmentQueryRunner<T>(new MetricsEmittingQueryRunner<T>(emitter,builderFn,factory.mergeRunners(MoreExecutors.sameThreadExecutor(),Iterables.transform(theSink,new Function<FireHydrant,QueryRunner<T>>(){
        @Override public QueryRunner<T> apply(        FireHydrant input){
          if (input == null || input.getSegment() == null) {
            return new ReportTimelineMissingSegmentQueryRunner<T>(descriptor);
          }
          if (skipIncrementalSegment && !input.hasSwapped()) {
            return new NoopQueryRunner<T>();
          }
          final ReferenceCountingSegment segment=input.getSegment();
          final Closeable closeable=segment.increment();
          try {
            if (input.hasSwapped() && cache.isLocal()) {
              return new CachingQueryRunner<>(makeHydrantIdentifier(input,segment),descriptor,objectMapper,cache,toolchest,factory.createRunner(segment),MoreExecutors.sameThreadExecutor(),cacheConfig);
            }
 else {
              return factory.createRunner(input.getSegment());
            }
          }
  finally {
            try {
              if (closeable != null) {
                closeable.close();
              }
            }
 catch (            IOException e) {
              throw Throwables.propagate(e);
            }
          }
        }
      }
))).withWaitMeasuredFromNow(),new SpecificSegmentSpec(descriptor));
    }
  }
)));
}
