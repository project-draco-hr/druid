{
  final boolean skipIncrementalSegment=query.getContextValue(SKIP_INCREMENTAL_SEGMENT,false);
  final QueryRunnerFactory<T,Query<T>> factory=conglomerate.findFactory(query);
  final QueryToolChest<T,Query<T>> toolchest=factory.getToolchest();
  final Function<Query<T>,ServiceMetricEvent.Builder> builderFn=new Function<Query<T>,ServiceMetricEvent.Builder>(){
    @Override public ServiceMetricEvent.Builder apply(    @Nullable Query<T> input){
      return toolchest.makeMetricBuilder(query);
    }
  }
;
  List<TimelineObjectHolder<String,Sink>> querySinks=Lists.newArrayList();
  for (  Interval interval : query.getIntervals()) {
    querySinks.addAll(sinkTimeline.lookup(interval));
  }
  return toolchest.mergeResults(factory.mergeRunners(queryExecutorService,FunctionalIterable.create(querySinks).transform(new Function<TimelineObjectHolder<String,Sink>,QueryRunner<T>>(){
    @Override public QueryRunner<T> apply(    TimelineObjectHolder<String,Sink> holder){
      if (holder == null) {
        throw new ISE("No timeline entry at all!");
      }
      final Sink theSink=holder.getObject().getChunk(0).getObject();
      if (theSink == null) {
        throw new ISE("Missing sink for timeline entry[%s]!",holder);
      }
      final SegmentDescriptor descriptor=new SegmentDescriptor(holder.getInterval(),theSink.getSegment().getVersion(),theSink.getSegment().getShardSpec().getPartitionNum());
      return new SpecificSegmentQueryRunner<T>(new MetricsEmittingQueryRunner<T>(emitter,builderFn,factory.mergeRunners(MoreExecutors.sameThreadExecutor(),Iterables.transform(theSink,new Function<FireHydrant,QueryRunner<T>>(){
        @Override public QueryRunner<T> apply(        FireHydrant input){
          if (input == null || input.getSegment() == null) {
            return new ReportTimelineMissingSegmentQueryRunner<T>(descriptor);
          }
          if (skipIncrementalSegment && !input.hasSwapped()) {
            return new NoopQueryRunner<T>();
          }
          final Pair<Segment,Closeable> segment=input.getAndIncrementSegment();
          try {
            QueryRunner<T> baseRunner=QueryRunnerHelper.makeClosingQueryRunner(factory.createRunner(segment.lhs),segment.rhs);
            if (input.hasSwapped() && cache.isLocal()) {
              return new CachingQueryRunner<>(makeHydrantIdentifier(input,segment.lhs),descriptor,objectMapper,cache,toolchest,baseRunner,MoreExecutors.sameThreadExecutor(),cacheConfig);
            }
 else {
              return baseRunner;
            }
          }
 catch (          RuntimeException e) {
            CloseQuietly.close(segment.rhs);
            throw e;
          }
        }
      }
))).withWaitMeasuredFromNow(),new SpecificSegmentSpec(descriptor));
    }
  }
)));
}
