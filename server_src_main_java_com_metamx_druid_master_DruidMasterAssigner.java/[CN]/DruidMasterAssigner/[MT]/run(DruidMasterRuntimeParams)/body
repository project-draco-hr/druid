{
  int unassignedCount=0;
  long unassignedSize=0;
  Map<String,Integer> assignedCounts=Maps.newHashMap();
  Map<String,MinMaxPriorityQueue<ServerHolder>> servers=params.getHistoricalServers();
  if (servers.isEmpty()) {
    log.warn("Uh... I have no servers. Not assigning anything...");
    return params;
  }
  for (  DataSegment segment : params.getAvailableSegments()) {
    Rule rule=params.getSegmentRules().get(segment.getIdentifier());
    if (rule instanceof LoadRule) {
      LoadRule loadRule=(LoadRule)rule;
      int expectedReplicants=loadRule.getReplicationFactor();
      int actualReplicants=(params.getSegmentsInCluster().get(segment.getIdentifier()) == null || params.getSegmentsInCluster().get(segment.getIdentifier()).get(loadRule.getNodeType()) == null) ? 0 : params.getSegmentsInCluster().get(segment.getIdentifier()).get(loadRule.getNodeType());
      MinMaxPriorityQueue<ServerHolder> serverQueue=params.getHistoricalServers().get(loadRule.getNodeType());
      if (serverQueue == null) {
        throw new ISE("No holders found for nodeType[%s]",loadRule.getNodeType());
      }
      List<ServerHolder> assignedServers=Lists.newArrayList();
      while (actualReplicants < expectedReplicants) {
        ServerHolder holder=serverQueue.pollFirst();
        if (holder == null) {
          log.warn("Not enough %s servers[%d] to assign segments!!!",loadRule.getNodeType(),serverQueue.size());
          break;
        }
        if (holder.getServer().getSegments().containsKey(segment.getIdentifier()) || holder.getPeon().getSegmentsToLoad().contains(segment)) {
          continue;
        }
        if (holder.getAvailableSize() < segment.getSize()) {
          log.warn("Not enough node capacity, closest is [%s] with %,d available, skipping segment[%s].",holder.getServer(),holder.getAvailableSize(),segment);
          params.getEmitter().emit(new AlertEvent.Builder().build("Not enough node capacity",ImmutableMap.<String,Object>builder().put("segmentSkipped",segment.toString()).put("closestNode",holder.getServer().toString()).put("availableSize",holder.getAvailableSize()).build()));
          serverQueue.add(holder);
          unassignedCount++;
          unassignedSize+=segment.getSize();
          break;
        }
        holder.getPeon().loadSegment(segment,new LoadPeonCallback(){
          @Override protected void execute(){
          }
        }
);
        assignedServers.add(holder);
        assignedCounts.put(loadRule.getNodeType(),assignedCounts.get(loadRule.getNodeType()) == null ? 1 : assignedCounts.get(loadRule.getNodeType()) + 1);
        ++actualReplicants;
      }
      serverQueue.addAll(assignedServers);
    }
  }
  master.decrementRemovedSegmentsLifetime();
  List<String> assignmentMsgs=Lists.newArrayList();
  for (  Map.Entry<String,Integer> entry : assignedCounts.entrySet()) {
    assignmentMsgs.add(String.format("[%s] : Assigned %,d segments among %,d servers",entry.getKey(),assignedCounts.get(entry.getKey()),servers.get(entry.getKey()).size()));
  }
  return params.buildFromExisting().withMessages(assignmentMsgs).withAssignedCount(assignedCounts).withUnassignedCount(unassignedCount).withUnassignedSize(unassignedSize).build();
}
