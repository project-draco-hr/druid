{
  Preconditions.checkState(sinks.isEmpty(),"Already bootstrapped?!");
  final File baseDir=tuningConfig.getBasePersistDirectory();
  if (!baseDir.exists()) {
    return null;
  }
  final File[] files=baseDir.listFiles();
  if (files == null) {
    return null;
  }
  final File commitFile=computeCommitFile();
  final Committed committed;
  try {
    if (commitFile.exists()) {
      committed=objectMapper.readValue(commitFile,Committed.class);
    }
 else {
      committed=Committed.nil();
    }
  }
 catch (  Exception e) {
    throw new ISE(e,"Failed to read commitFile: %s",commitFile);
  }
  log.info("Loading sinks from[%s]: %s",baseDir,committed.getHydrants().keySet());
  for (  File sinkDir : files) {
    final File identifierFile=new File(sinkDir,IDENTIFIER_FILE_NAME);
    if (!identifierFile.isFile()) {
      continue;
    }
    try {
      final SegmentIdentifier identifier=objectMapper.readValue(new File(sinkDir,"identifier.json"),SegmentIdentifier.class);
      final int committedHydrants=committed.getCommittedHydrants(identifier.getIdentifierAsString());
      if (committedHydrants <= 0) {
        log.info("Removing uncommitted sink at [%s]",sinkDir);
        FileUtils.deleteDirectory(sinkDir);
        continue;
      }
      final File[] sinkFiles=sinkDir.listFiles(new FilenameFilter(){
        @Override public boolean accept(        File dir,        String fileName){
          return !(Ints.tryParse(fileName) == null);
        }
      }
);
      Arrays.sort(sinkFiles,new Comparator<File>(){
        @Override public int compare(        File o1,        File o2){
          return Ints.compare(Integer.parseInt(o1.getName()),Integer.parseInt(o2.getName()));
        }
      }
);
      List<FireHydrant> hydrants=Lists.newArrayList();
      for (      File hydrantDir : sinkFiles) {
        final int hydrantNumber=Integer.parseInt(hydrantDir.getName());
        if (hydrantNumber >= committedHydrants) {
          log.info("Removing uncommitted segment at [%s]",hydrantDir);
          FileUtils.deleteDirectory(hydrantDir);
        }
 else {
          log.info("Loading previously persisted segment at [%s]",hydrantDir);
          if (hydrantNumber != hydrants.size()) {
            throw new ISE("Missing hydrant [%,d] in sinkDir [%s].",hydrants.size(),sinkDir);
          }
          hydrants.add(new FireHydrant(new QueryableIndexSegment(identifier.getIdentifierAsString(),indexIO.loadIndex(hydrantDir)),hydrantNumber));
        }
      }
      if (committedHydrants != hydrants.size()) {
        throw new ISE("Missing hydrant [%,d] in sinkDir [%s].",hydrants.size(),sinkDir);
      }
      Sink currSink=new Sink(identifier.getInterval(),schema,identifier.getShardSpec(),identifier.getVersion(),tuningConfig.getMaxRowsInMemory(),tuningConfig.isReportParseExceptions(),hydrants);
      sinks.put(identifier,currSink);
      sinkTimeline.add(currSink.getInterval(),currSink.getVersion(),identifier.getShardSpec().createChunk(currSink));
      segmentAnnouncer.announceSegment(currSink.getSegment());
    }
 catch (    IOException e) {
      log.makeAlert(e,"Problem loading sink[%s] from disk.",schema.getDataSource()).addData("sinkDir",sinkDir).emit();
    }
  }
  final Set<String> loadedSinks=Sets.newHashSet(Iterables.transform(sinks.keySet(),new Function<SegmentIdentifier,String>(){
    @Override public String apply(    SegmentIdentifier input){
      return input.getIdentifierAsString();
    }
  }
));
  final Set<String> missingSinks=Sets.difference(committed.getHydrants().keySet(),loadedSinks);
  if (!missingSinks.isEmpty()) {
    throw new ISE("Missing committed sinks [%s]",Joiner.on(", ").join(missingSinks));
  }
  return committed.getMetadata();
}
