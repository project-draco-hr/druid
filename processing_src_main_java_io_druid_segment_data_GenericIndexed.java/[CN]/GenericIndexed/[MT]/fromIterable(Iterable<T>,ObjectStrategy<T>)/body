{
  Iterator<T> objects=objectsIterable.iterator();
  if (!objects.hasNext()) {
    final ByteBuffer buffer=ByteBuffer.allocate(4).putInt(0);
    buffer.flip();
    return new GenericIndexed<T>(buffer,strategy,true);
  }
  boolean allowReverseLookup=true;
  int count=1;
  T prevVal=objects.next();
  while (objects.hasNext()) {
    T next=objects.next();
    if (!(strategy.compare(prevVal,next) < 0)) {
      allowReverseLookup=false;
    }
    if (prevVal instanceof Closeable) {
      CloseQuietly.close((Closeable)prevVal);
    }
    prevVal=next;
    ++count;
  }
  if (prevVal instanceof Closeable) {
    CloseQuietly.close((Closeable)prevVal);
  }
  ByteArrayOutputStream headerBytes=new ByteArrayOutputStream(4 + (count * 4));
  ByteArrayOutputStream valueBytes=new ByteArrayOutputStream();
  int offset=0;
  try {
    headerBytes.write(Ints.toByteArray(count));
    for (    T object : objectsIterable) {
      final byte[] bytes=strategy.toBytes(object);
      offset+=4 + bytes.length;
      headerBytes.write(Ints.toByteArray(offset));
      valueBytes.write(Ints.toByteArray(bytes.length));
      valueBytes.write(bytes);
      if (object instanceof Closeable) {
        CloseQuietly.close((Closeable)object);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  ByteBuffer theBuffer=ByteBuffer.allocate(headerBytes.size() + valueBytes.size());
  theBuffer.put(headerBytes.toByteArray());
  theBuffer.put(valueBytes.toByteArray());
  theBuffer.flip();
  return new GenericIndexed<T>(theBuffer.asReadOnlyBuffer(),strategy,allowReverseLookup);
}
