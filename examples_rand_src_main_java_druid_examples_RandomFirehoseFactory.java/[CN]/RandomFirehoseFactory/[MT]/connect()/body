{
  return new Firehose(){
    private final Runnable commitRunnable=new Runnable(){
      public void run(){
      }
    }
;
    private final java.util.Random rand=(seed == 0L) ? new Random() : new Random(seed);
    private final LinkedList<String> dimensions=new LinkedList<String>();
    private final boolean placeholderForAdd=dimensions.add("inColumn".toLowerCase());
    private final boolean placeholderForAdd2=dimensions.add("target".toLowerCase());
    private final Map<String,Object> theMap=new HashMap<String,Object>(2);
    private long rowCount=0L;
    private boolean waitIfmaxGeneratedRows=true;
    @Override public boolean hasMore(){
      if (maxGeneratedRows >= 0 && rowCount >= maxGeneratedRows) {
        return waitIfmaxGeneratedRows;
      }
 else {
        return true;
      }
    }
    @Override public InputRow nextRow(){
      final long modulus=rowCount % nPerSleep;
      final long nth=(rowCount % nTokens) + 1;
      long sleepMsec=delayMsec;
      if (maxGeneratedRows >= 0 && rowCount >= maxGeneratedRows && waitIfmaxGeneratedRows) {
        sleepMsec=2000000000L;
      }
      if (sleepMsec > 0L || delayNsec > 0) {
        try {
          if (modulus == 0) {
            sleep(sleepMsec,delayNsec);
          }
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("InterruptedException");
        }
      }
      rowCount++;
      theMap.put("inColumn".toLowerCase(),anotherRand((int)nth));
      theMap.put("target",("a" + nth));
      return new MapBasedInputRow(System.currentTimeMillis(),dimensions,theMap);
    }
    private Float anotherRand(    int scale){
      double f=rand.nextDouble();
      return new Float(f + (double)scale);
    }
    @Override public Runnable commit(){
      return commitRunnable;
    }
    @Override public void close() throws IOException {
      ;
    }
  }
;
}
