{
synchronized (cacheCache) {
    final Cache cachedCache=cacheCache.get(identifier);
    if (cachedCache != null) {
      return cachedCache;
    }
    final byte[] myIdBytes=Ints.toByteArray(ids.getAndIncrement());
    final Cache theCache=new Cache(){
      volatile boolean open=true;
      @Override public byte[] get(      byte[] key){
        if (open) {
          final byte[] retVal=baseMap.get(computeKey(key));
          if (retVal == null) {
            missCount.incrementAndGet();
          }
 else {
            hitCount.incrementAndGet();
          }
          return retVal;
        }
        throw new ISE("Cache for namespace[%s] is closed.",identifier);
      }
      @Override public void put(      byte[] key,      byte[] value){
synchronized (clearLock) {
          if (open) {
            baseMap.put(computeKey(key),value);
            return;
          }
        }
        throw new ISE("Cache for namespace[%s] is closed.",identifier);
      }
      @Override public void close(){
synchronized (cacheCache) {
          cacheCache.remove(identifier);
        }
synchronized (clearLock) {
          if (open) {
            open=false;
            Iterator<ByteBuffer> iter=baseMap.keySet().iterator();
            while (iter.hasNext()) {
              ByteBuffer next=iter.next();
              if (next.get(0) == myIdBytes[0] && next.get(1) == myIdBytes[1] && next.get(2) == myIdBytes[2] && next.get(3) == myIdBytes[3]) {
                iter.remove();
              }
            }
          }
        }
      }
      private ByteBuffer computeKey(      byte[] key){
        final ByteBuffer retVal=ByteBuffer.allocate(key.length + 4).put(myIdBytes).put(key);
        retVal.rewind();
        return retVal;
      }
    }
;
    cacheCache.put(identifier,theCache);
    return theCache;
  }
}
