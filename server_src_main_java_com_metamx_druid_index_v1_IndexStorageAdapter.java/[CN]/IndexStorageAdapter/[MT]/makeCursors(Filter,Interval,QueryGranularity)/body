{
  Interval actualIntervalTmp=interval;
  if (!actualIntervalTmp.overlaps(index.dataInterval)) {
    return ImmutableList.of();
  }
  if (actualIntervalTmp.getStart().isBefore(index.dataInterval.getStart())) {
    actualIntervalTmp=actualIntervalTmp.withStart(index.dataInterval.getStart());
  }
  if (actualIntervalTmp.getEnd().isAfter(index.dataInterval.getEnd())) {
    actualIntervalTmp=actualIntervalTmp.withEnd(index.dataInterval.getEnd());
  }
  final Interval actualInterval=actualIntervalTmp;
  final Pair<Integer,Integer> intervalStartAndEnd=computeTimeStartEnd(actualInterval);
  return new Iterable<Cursor>(){
    @Override public Iterator<Cursor> iterator(){
      final Offset baseOffset;
      if (filter == null) {
        baseOffset=new ArrayBasedOffset(ids,intervalStartAndEnd.lhs);
      }
 else {
        baseOffset=new StartLimitedOffset(new ConciseOffset(filter.goConcise(new IndexBasedBitmapIndexSelector(index))),intervalStartAndEnd.lhs);
      }
      final Map<String,Object> metricHolderCache=Maps.newHashMap();
      return MoreIterators.after(FunctionalIterator.create(gran.iterable(actualInterval.getStartMillis(),actualInterval.getEndMillis()).iterator()).keep(new Function<Long,Cursor>(){
        @Override public Cursor apply(        final Long intervalStart){
          final Offset offset=new TimestampCheckingOffset(baseOffset,index.timeOffsets,Math.min(actualInterval.getEndMillis(),gran.next(intervalStart)));
          return new Cursor(){
            private final Offset initOffset=offset.clone();
            private Offset cursorOffset=offset;
            private final DateTime timestamp=gran.toDateTime(intervalStart);
            @Override public DateTime getTime(){
              return timestamp;
            }
            @Override public void advance(){
              cursorOffset.increment();
            }
            @Override public boolean isDone(){
              return !cursorOffset.withinBounds();
            }
            @Override public void reset(){
              cursorOffset=initOffset.clone();
            }
            @Override public DimensionSelector makeDimensionSelector(            String dimension){
              final String dimensionName=dimension.toLowerCase();
              final String[] nameLookup=index.reverseDimLookup.get(dimensionName);
              if (nameLookup == null) {
                return null;
              }
              return new DimensionSelector(){
                final Map<String,Integer> dimValLookup=index.dimIdLookup.get(dimensionName);
                final DimensionColumn dimColumn=index.dimensionValues.get(dimensionName);
                final int[][] dimensionExpansions=dimColumn.getDimensionExpansions();
                final int[] dimensionRowValues=dimColumn.getDimensionRowValues();
                @Override public IndexedInts getRow(){
                  return new ArrayBasedIndexedInts(dimensionExpansions[dimensionRowValues[cursorOffset.getOffset()]]);
                }
                @Override public int getValueCardinality(){
                  return nameLookup.length;
                }
                @Override public String lookupName(                int id){
                  return nameLookup[id];
                }
                @Override public int lookupId(                String name){
                  final Integer retVal=dimValLookup.get(name);
                  return retVal == null ? -1 : retVal;
                }
              }
;
            }
            @Override public FloatMetricSelector makeFloatMetricSelector(            String metric){
              String metricName=metric.toLowerCase();
              IndexedFloats cachedFloats=(IndexedFloats)metricHolderCache.get(metric);
              if (cachedFloats == null) {
                MetricHolder holder=index.metricVals.get(metricName);
                if (holder == null) {
                  return new FloatMetricSelector(){
                    @Override public float get(){
                      return 0.0f;
                    }
                  }
;
                }
                cachedFloats=holder.getFloatType();
                metricHolderCache.put(metricName,cachedFloats);
              }
              final IndexedFloats metricVals=cachedFloats;
              return new FloatMetricSelector(){
                @Override public float get(){
                  return metricVals.get(cursorOffset.getOffset());
                }
              }
;
            }
            @Override public ComplexMetricSelector makeComplexMetricSelector(            String metric){
              final String metricName=metric.toLowerCase();
              Indexed cachedComplex=(Indexed)metricHolderCache.get(metricName);
              if (cachedComplex == null) {
                MetricHolder holder=index.metricVals.get(metricName);
                if (holder != null) {
                  cachedComplex=holder.getComplexType();
                  metricHolderCache.put(metricName,cachedComplex);
                }
              }
              if (cachedComplex == null) {
                return null;
              }
              final Indexed vals=cachedComplex;
              return new ComplexMetricSelector(){
                @Override public Class classOfObject(){
                  return vals.getClazz();
                }
                @Override public Object get(){
                  return vals.get(cursorOffset.getOffset());
                }
              }
;
            }
          }
;
        }
      }
),new Runnable(){
        @Override public void run(){
          for (          Object object : metricHolderCache.values()) {
            if (object instanceof Closeable) {
              Closeables.closeQuietly((Closeable)object);
            }
          }
        }
      }
);
    }
  }
;
}
