{
  Interval actualIntervalTmp=interval;
  if (!actualIntervalTmp.overlaps(index.dataInterval)) {
    return ImmutableList.of();
  }
  if (actualIntervalTmp.getStart().isBefore(index.dataInterval.getStart())) {
    actualIntervalTmp=actualIntervalTmp.withStart(index.dataInterval.getStart());
  }
  if (actualIntervalTmp.getEnd().isAfter(index.dataInterval.getEnd())) {
    actualIntervalTmp=actualIntervalTmp.withEnd(index.dataInterval.getEnd());
  }
  final Interval actualInterval=actualIntervalTmp;
  final Pair<Integer,Integer> intervalStartAndEnd=computeTimeStartEnd(actualInterval);
  return new Iterable<Cursor>(){
    @Override public Iterator<Cursor> iterator(){
      final Offset baseOffset;
      if (filter == null) {
        baseOffset=new ArrayBasedOffset(ids,intervalStartAndEnd.lhs);
      }
 else {
        baseOffset=new StartLimitedOffset(new ConciseOffset(filter.goConcise(new IndexBasedBitmapIndexSelector(index))),intervalStartAndEnd.lhs);
      }
      final Map<String,Object> columnHolderCache=Maps.newHashMap();
      return MoreIterators.after(FunctionalIterator.create(gran.iterable(actualInterval.getStartMillis(),actualInterval.getEndMillis()).iterator()).keep(new Function<Long,Cursor>(){
        @Override public Cursor apply(        final Long intervalStart){
          final Offset offset=new TimestampCheckingOffset(baseOffset,index.timeOffsets,Math.min(actualInterval.getEndMillis(),gran.next(intervalStart)));
          return new Cursor(){
            private final Offset initOffset=offset.clone();
            private Offset cursorOffset=offset;
            private final DateTime timestamp=gran.toDateTime(intervalStart);
            @Override public DateTime getTime(){
              return timestamp;
            }
            @Override public void advance(){
              cursorOffset.increment();
            }
            @Override public boolean isDone(){
              return !cursorOffset.withinBounds();
            }
            @Override public void reset(){
              cursorOffset=initOffset.clone();
            }
            @Override public DimensionSelector makeDimensionSelector(            String dimension){
              final String dimensionName=dimension.toLowerCase();
              final String[] nameLookup=index.reverseDimLookup.get(dimensionName);
              if (nameLookup == null) {
                return null;
              }
              return new DimensionSelector(){
                final Map<String,Integer> dimValLookup=index.dimIdLookup.get(dimensionName);
                final DimensionColumn dimColumn=index.dimensionValues.get(dimensionName);
                final int[][] dimensionExpansions=dimColumn.getDimensionExpansions();
                final int[] dimensionRowValues=dimColumn.getDimensionRowValues();
                @Override public IndexedInts getRow(){
                  return new ArrayBasedIndexedInts(dimensionExpansions[dimensionRowValues[cursorOffset.getOffset()]]);
                }
                @Override public int getValueCardinality(){
                  return nameLookup.length;
                }
                @Override public String lookupName(                int id){
                  return nameLookup[id];
                }
                @Override public int lookupId(                String name){
                  final Integer retVal=dimValLookup.get(name);
                  return retVal == null ? -1 : retVal;
                }
              }
;
            }
            @Override public FloatMetricSelector makeFloatMetricSelector(            String metric){
              String metricName=metric.toLowerCase();
              IndexedFloats cachedFloats=(IndexedFloats)columnHolderCache.get(metric);
              if (cachedFloats == null) {
                MetricHolder holder=index.metricVals.get(metricName);
                if (holder == null) {
                  return new FloatMetricSelector(){
                    @Override public float get(){
                      return 0.0f;
                    }
                  }
;
                }
                cachedFloats=holder.getFloatType();
                columnHolderCache.put(metricName,cachedFloats);
              }
              final IndexedFloats metricVals=cachedFloats;
              return new FloatMetricSelector(){
                @Override public float get(){
                  return metricVals.get(cursorOffset.getOffset());
                }
              }
;
            }
            @Override public ComplexMetricSelector makeComplexMetricSelector(            String metric){
              final String metricName=metric.toLowerCase();
              Indexed cachedComplex=(Indexed)columnHolderCache.get(metricName);
              if (cachedComplex == null) {
                MetricHolder holder=index.metricVals.get(metricName);
                if (holder != null) {
                  cachedComplex=holder.getComplexType();
                  columnHolderCache.put(metricName,cachedComplex);
                }
              }
              if (cachedComplex == null) {
                return null;
              }
              final Indexed vals=cachedComplex;
              return new ComplexMetricSelector(){
                @Override public Class classOfObject(){
                  return vals.getClazz();
                }
                @Override public Object get(){
                  return vals.get(cursorOffset.getOffset());
                }
              }
;
            }
            @Override public ObjectColumnSelector makeObjectColumnSelector(            String column){
              final String columnName=column.toLowerCase();
              Object cachedColumn=(Indexed)columnHolderCache.get(columnName);
              if (cachedColumn == null) {
                MetricHolder holder=index.metricVals.get(columnName);
                final String[] nameLookup=index.reverseDimLookup.get(columnName);
                if (nameLookup != null) {
                  cachedColumn=index.dimensionValues.get(columnName);
                }
 else                 if (holder != null) {
                  final MetricHolder.MetricType type=holder.getType();
                  if (type == MetricHolder.MetricType.COMPLEX) {
                    cachedColumn=holder.getComplexType();
                  }
 else {
                    cachedColumn=holder.getFloatType();
                  }
                }
                if (cachedColumn != null) {
                  columnHolderCache.put(columnName,cachedColumn);
                }
              }
              if (cachedColumn == null) {
                return null;
              }
              if (cachedColumn instanceof IndexedFloats) {
                final IndexedFloats vals=(IndexedFloats)cachedColumn;
                return new ObjectColumnSelector<Float>(){
                  @Override public Class classOfObject(){
                    return Float.TYPE;
                  }
                  @Override public Float get(){
                    return vals.get(cursorOffset.getOffset());
                  }
                }
;
              }
              if (cachedColumn instanceof Indexed) {
                final Indexed vals=(Indexed)cachedColumn;
                return new ObjectColumnSelector(){
                  @Override public Class classOfObject(){
                    return vals.getClazz();
                  }
                  @Override public Object get(){
                    return vals.get(cursorOffset.getOffset());
                  }
                }
;
              }
              if (cachedColumn instanceof DimensionColumn) {
                final DimensionColumn vals=(DimensionColumn)cachedColumn;
                final String[] nameLookup=index.reverseDimLookup.get(columnName);
                final int[] dimensionRowValues=vals.getDimensionRowValues();
                final int[][] dimensionExpansions=vals.getDimensionExpansions();
                return new ObjectColumnSelector<String>(){
                  @Override public Class classOfObject(){
                    return String.class;
                  }
                  @Override public String get(){
                    final int[] dimIds=dimensionExpansions[dimensionRowValues[cursorOffset.getOffset()]];
                    if (dimIds.length == 1)                     return nameLookup[dimIds[0]];
                    if (dimIds.length == 0)                     return null;
                    throw new UnsupportedOperationException("makeObjectColumnSelector does not support multivalued columns");
                  }
                }
;
              }
              return null;
            }
          }
;
        }
      }
),new Runnable(){
        @Override public void run(){
          for (          Object object : columnHolderCache.values()) {
            if (object instanceof Closeable) {
              Closeables.closeQuietly((Closeable)object);
            }
          }
        }
      }
);
    }
  }
;
}
