{
  return new QueryRunner<SegmentAnalysis>(){
    @Override public Sequence<SegmentAnalysis> run(    Query<SegmentAnalysis> inQ,    Map<String,Object> responseContext){
      SegmentMetadataQuery query=(SegmentMetadataQuery)inQ;
      final SegmentAnalyzer analyzer=new SegmentAnalyzer(query.getAnalysisTypes());
      final Map<String,ColumnAnalysis> analyzedColumns=analyzer.analyze(segment);
      final int numRows=analyzer.numRows(segment);
      long totalSize=0;
      if (analyzer.analyzingSize()) {
        totalSize=analyzedColumns.size() * numRows;
      }
      Map<String,ColumnAnalysis> columns=Maps.newTreeMap();
      ColumnIncluderator includerator=query.getToInclude();
      for (      Map.Entry<String,ColumnAnalysis> entry : analyzedColumns.entrySet()) {
        final String columnName=entry.getKey();
        final ColumnAnalysis column=entry.getValue();
        if (!column.isError()) {
          totalSize+=column.getSize();
        }
        if (includerator.include(columnName)) {
          columns.put(columnName,column);
        }
      }
      List<Interval> retIntervals=query.analyzingInterval() ? Arrays.asList(segment.getDataInterval()) : null;
      final Map<String,AggregatorFactory> aggregators;
      if (query.hasAggregators()) {
        final Metadata metadata=segment.asStorageAdapter().getMetadata();
        if (metadata != null && metadata.getAggregators() != null) {
          aggregators=Maps.newHashMap();
          for (          AggregatorFactory aggregator : metadata.getAggregators()) {
            aggregators.put(aggregator.getName(),aggregator);
          }
        }
 else {
          aggregators=null;
        }
      }
 else {
        aggregators=null;
      }
      return Sequences.simple(Arrays.asList(new SegmentAnalysis(segment.getIdentifier(),retIntervals,columns,totalSize,numRows,aggregators)));
    }
  }
;
}
