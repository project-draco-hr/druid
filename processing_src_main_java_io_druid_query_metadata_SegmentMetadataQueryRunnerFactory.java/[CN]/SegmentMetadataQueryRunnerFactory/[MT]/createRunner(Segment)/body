{
  return new QueryRunner<SegmentAnalysis>(){
    @Override public Sequence<SegmentAnalysis> run(    Query<SegmentAnalysis> inQ,    Map<String,Object> responseContext){
      SegmentMetadataQuery query=(SegmentMetadataQuery)inQ;
      final QueryableIndex index=segment.asQueryableIndex();
      final Map<String,ColumnAnalysis> analyzedColumns;
      final int numRows;
      long totalSize=0;
      if (index == null) {
        StorageAdapter segmentAdapter=segment.asStorageAdapter();
        analyzedColumns=analyzer.analyze(segmentAdapter,query.getAnalysisTypes());
        numRows=segmentAdapter.getNumRows();
      }
 else {
        analyzedColumns=analyzer.analyze(index,query.getAnalysisTypes());
        numRows=index.getNumRows();
      }
      if (query.hasSize()) {
        totalSize=analyzedColumns.size() * numRows;
      }
      Map<String,ColumnAnalysis> columns=Maps.newTreeMap();
      ColumnIncluderator includerator=query.getToInclude();
      for (      Map.Entry<String,ColumnAnalysis> entry : analyzedColumns.entrySet()) {
        final String columnName=entry.getKey();
        final ColumnAnalysis column=entry.getValue();
        if (!column.isError()) {
          totalSize+=column.getSize();
        }
        if (includerator.include(columnName)) {
          columns.put(columnName,column);
        }
      }
      List<Interval> retIntervals=query.hasInterval() ? Arrays.asList(segment.getDataInterval()) : null;
      return Sequences.simple(Arrays.asList(new SegmentAnalysis(segment.getIdentifier(),retIntervals,columns,totalSize,numRows)));
    }
  }
;
}
