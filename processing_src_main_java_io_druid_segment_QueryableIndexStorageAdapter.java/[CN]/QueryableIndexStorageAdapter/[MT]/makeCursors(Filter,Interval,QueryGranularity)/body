{
  Interval actualInterval=interval;
  final Interval dataInterval=new Interval(getMinTime().getMillis(),gran.next(gran.truncate(getMaxTime().getMillis())));
  if (!actualInterval.overlaps(dataInterval)) {
    return Sequences.empty();
  }
  if (actualInterval.getStart().isBefore(dataInterval.getStart())) {
    actualInterval=actualInterval.withStart(dataInterval.getStart());
  }
  if (actualInterval.getEnd().isAfter(dataInterval.getEnd())) {
    actualInterval=actualInterval.withEnd(dataInterval.getEnd());
  }
  final Sequence<Cursor> sequence;
  if (filter == null) {
    sequence=new NoFilterCursorSequenceBuilder(index,actualInterval,gran).build();
  }
 else {
    Offset offset=new ConciseOffset(filter.goConcise(new ColumnSelectorBitmapIndexSelector(index)));
    sequence=new CursorSequenceBuilder(index,actualInterval,gran,offset).build();
  }
  return Sequences.filter(sequence,Predicates.<Cursor>notNull());
}
