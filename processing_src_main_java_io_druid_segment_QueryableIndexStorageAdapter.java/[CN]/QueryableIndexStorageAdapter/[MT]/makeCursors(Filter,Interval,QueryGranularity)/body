{
  Interval actualInterval=interval;
  final Interval dataInterval=new Interval(getMinTime().getMillis(),gran.next(gran.truncate(getMaxTime().getMillis())));
  if (!actualInterval.overlaps(dataInterval)) {
    return Sequences.empty();
  }
  if (actualInterval.getStart().isBefore(dataInterval.getStart())) {
    actualInterval=actualInterval.withStart(dataInterval.getStart());
  }
  if (actualInterval.getEnd().isAfter(dataInterval.getEnd())) {
    actualInterval=actualInterval.withEnd(dataInterval.getEnd());
  }
  final Offset offset;
  if (filter == null) {
    offset=new NoFilterOffset(0,index.getNumRows());
  }
 else {
    offset=new ConciseOffset(filter.goConcise(new ColumnSelectorBitmapIndexSelector(index)));
  }
  return Sequences.filter(new CursorSequenceBuilder(index,actualInterval,gran,offset).build(),Predicates.<Cursor>notNull());
}
