{
  this.listeningScheduledExecutorService=MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(1,new ThreadFactoryBuilder().setDaemon(true).setNameFormat("NamespaceExtractionCacheManager-%d").setPriority(Thread.MIN_PRIORITY).build()));
  ExecutorServices.manageLifecycle(lifecycle,listeningScheduledExecutorService);
  this.serviceEmitter=serviceEmitter;
  this.fnCache=fnCache;
  this.reverseFnCache=reverseFnCache;
  this.namespaceFunctionFactoryMap=namespaceFunctionFactoryMap;
  listeningScheduledExecutorService.scheduleAtFixedRate(new Runnable(){
    long priorTasksStarted=0L;
    @Override public void run(){
      try {
        final long tasks=tasksStarted.get();
        serviceEmitter.emit(ServiceMetricEvent.builder().build("namespace/size",dataSize.get()));
        serviceEmitter.emit(ServiceMetricEvent.builder().build("namespace/count",fnCache.size()));
        serviceEmitter.emit(ServiceMetricEvent.builder().build("namespace/deltaTasksStarted",tasks - priorTasksStarted));
        priorTasksStarted=tasks;
      }
 catch (      Exception e) {
        log.error(e,"Error emitting namespace stats");
        if (Thread.currentThread().isInterrupted()) {
          throw Throwables.propagate(e);
        }
      }
    }
  }
,1,10,TimeUnit.MINUTES);
}
