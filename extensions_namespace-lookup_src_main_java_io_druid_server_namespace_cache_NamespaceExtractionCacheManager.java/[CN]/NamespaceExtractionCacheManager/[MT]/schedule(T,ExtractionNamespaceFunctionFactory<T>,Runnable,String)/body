{
  final String namespaceName=namespace.getNamespace();
  log.debug("Trying to update namespace [%s]",namespaceName);
  final AtomicReference<NamespaceImplData> implDatum=new AtomicReference<>(implData.get(namespaceName));
  if (implDatum.get() != null) {
synchronized (implDatum.get().enabled) {
      if (implDatum.get().enabled.get()) {
        throw new IAE("Namespace [%s] already exists! Leaving prior running",namespace.toString());
      }
    }
  }
  final CountDownLatch startLatch=new CountDownLatch(1);
  try {
    ListenableFuture<?> future=null;
    try {
      if (namespace.getPollMs() > 0) {
        final long updateMs=namespace.getPollMs();
        future=listeningScheduledExecutorService.scheduleAtFixedRate(new Runnable(){
          @Override public void run(){
            try {
              startLatch.await();
              if (!Thread.interrupted()) {
                final Map<String,String> cache=getCacheMap(cacheId);
                final String preVersion=lastVersion.get(namespaceName);
                final Callable<String> runnable=factory.getCachePopulator(namespace,preVersion,cache);
                tasksStarted.incrementAndGet();
                final String newVersion=runnable.call();
                if (newVersion != null) {
                  lastVersion.put(namespaceName,newVersion);
                }
                if (preVersion == null || !preVersion.equals(lastVersion.get(namespaceName))) {
                  postRunnable.run();
                }
 else {
                  delete(cacheId);
                }
              }
 else {
                Thread.currentThread().interrupt();
              }
            }
 catch (            Exception e) {
              if (e instanceof CancellationException) {
                log.debug("Thread for namespace[%s] cancelled",namespaceName);
              }
 else {
                log.error(e,"Error in listener for namespace [%s]",namespaceName);
              }
              delete(cacheId);
              throw Throwables.propagate(e);
            }
          }
        }
,0,updateMs,TimeUnit.MILLISECONDS);
      }
 else {
        final Map<String,String> cache=getCacheMap(cacheId);
        final Callable<String> runnable=factory.getCachePopulator(namespace,null,cache);
        final ListenableFuture<String> futureWithString=listeningScheduledExecutorService.schedule(new Callable<String>(){
          @Override public String call() throws Exception {
            startLatch.await();
            tasksStarted.incrementAndGet();
            return runnable.call();
          }
        }
,0,TimeUnit.MILLISECONDS);
        Futures.addCallback(futureWithString,new FutureCallback<String>(){
          @Override public void onSuccess(          String result){
            try {
              postRunnable.run();
            }
 catch (            RuntimeException e) {
              delete(cacheId);
              throw e;
            }
            if (implDatum.get().enabled.get()) {
              lastVersion.put(namespaceName,result);
            }
          }
          @Override public void onFailure(          Throwable t){
          }
        }
);
        future=futureWithString;
      }
    }
 catch (    Exception e) {
      if (future != null) {
        if (!future.isDone() && !future.cancel(true)) {
          log.warn("Could not cancel future for [%s]",namespaceName);
        }
      }
      throw Throwables.propagate(e);
    }
    Futures.addCallback(future,new FutureCallback<Object>(){
      @Override public void onSuccess(      @Nullable Object result){
        log.debug("Namespace [%s] successfully updated",namespaceName);
      }
      @Override public void onFailure(      Throwable t){
        delete(cacheId);
        if (t instanceof CancellationException) {
          log.debug(t,"Namespace [%s] cancelled",namespaceName);
        }
 else {
          log.error(t,"Failed update namespace [%s]",namespace);
        }
      }
    }
);
    final NamespaceImplData me=new NamespaceImplData(future,namespace,namespaceName);
    final NamespaceImplData other=implData.putIfAbsent(namespaceName,me);
    if (other != null) {
      if (!future.isDone() && !future.cancel(true)) {
        log.warn("Unable to cancle future for namespace[%s] on race loss",namespaceName);
      }
      throw new IAE("Namespace [%s] already exists! Leaving prior running",namespace);
    }
 else {
      if (!me.enabled.compareAndSet(false,true)) {
        log.wtf("How did someone enable this before ME?");
      }
      implDatum.set(me);
      log.debug("I own namespace [%s]",namespaceName);
      return future;
    }
  }
  finally {
    startLatch.countDown();
  }
}
