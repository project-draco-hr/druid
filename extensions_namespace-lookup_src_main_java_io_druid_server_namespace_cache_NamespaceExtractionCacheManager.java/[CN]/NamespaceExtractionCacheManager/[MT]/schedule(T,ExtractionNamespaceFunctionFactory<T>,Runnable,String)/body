{
  final String namespaceName=namespace.getNamespace();
  log.debug("Trying to update namespace [%s]",namespaceName);
  final NamespaceImplData implDatum=implData.get(namespaceName);
  if (implDatum != null) {
synchronized (implDatum.enabled) {
      if (implDatum.enabled.get()) {
        throw new IAE("Namespace [%s] already exists! Leaving prior running",namespace.toString());
      }
    }
  }
  final long updateMs=namespace.getPollMs();
  final CountDownLatch startLatch=new CountDownLatch(1);
  final Runnable command=new Runnable(){
    @Override public void run(){
      try {
        startLatch.await();
        if (!Thread.currentThread().isInterrupted()) {
          final Map<String,String> cache=getCacheMap(cacheId);
          final String preVersion=lastVersion.get(namespaceName);
          final Callable<String> runnable=factory.getCachePopulator(namespace,preVersion,cache);
          tasksStarted.incrementAndGet();
          final String newVersion=runnable.call();
          if (preVersion != null && preVersion.equals(newVersion)) {
            throw new IllegalStateException("Already exists");
          }
          if (newVersion != null) {
            lastVersion.put(namespaceName,newVersion);
          }
          postRunnable.run();
          log.debug("Namespace [%s] successfully updated",namespaceName);
        }
      }
 catch (      Throwable t) {
        delete(cacheId);
        if (t instanceof CancellationException) {
          log.debug(t,"Namespace [%s] cancelled",namespaceName);
        }
 else {
          log.error(t,"Failed update namespace [%s]",namespace);
        }
      }
    }
  }
;
  ListenableFuture<?> future;
  try {
    if (updateMs > 0) {
      future=listeningScheduledExecutorService.scheduleAtFixedRate(command,0,updateMs,TimeUnit.MILLISECONDS);
    }
 else {
      future=listeningScheduledExecutorService.schedule(command,0,TimeUnit.MILLISECONDS);
    }
    final NamespaceImplData me=new NamespaceImplData(future,namespace,namespaceName);
    final NamespaceImplData other=implData.putIfAbsent(namespaceName,me);
    if (other != null) {
      if (!future.isDone() && !future.cancel(true)) {
        log.warn("Unable to cancel future for namespace[%s] on race loss",namespaceName);
      }
      throw new IAE("Namespace [%s] already exists! Leaving prior running",namespace);
    }
 else {
      if (!me.enabled.compareAndSet(false,true)) {
        log.wtf("How did someone enable this before ME?");
      }
      log.debug("I own namespace [%s]",namespaceName);
      return future;
    }
  }
  finally {
    startLatch.countDown();
  }
}
