{
  MMappedIndex index=IndexIO.mapDir(inDir);
  Map<String,Column> columns=Maps.newHashMap();
  for (  String dimension : index.getAvailableDimensions()) {
    columns.put(dimension.toLowerCase(),new ColumnBuilder().setType(ValueType.STRING).setHasMultipleValues(true).setDictionaryEncodedColumn(new DictionaryEncodedColumnSupplier(index.getDimValueLookup(dimension),null,(index.getDimColumn(dimension)))).setBitmapIndex(new BitmapIndexColumnPartSupplier(index.getInvertedIndexes().get(dimension),index.getDimValueLookup(dimension))).build());
  }
  for (  String metric : index.getAvailableMetrics()) {
    final MetricHolder metricHolder=index.getMetricHolder(metric);
    if (metricHolder.getType() == MetricHolder.MetricType.FLOAT) {
      columns.put(metric.toLowerCase(),new ColumnBuilder().setType(ValueType.FLOAT).setGenericColumn(new FloatGenericColumnSupplier(metricHolder.floatType,BYTE_ORDER)).build());
    }
 else     if (metricHolder.getType() == MetricHolder.MetricType.COMPLEX) {
      columns.put(metric.toLowerCase(),new ColumnBuilder().setType(ValueType.COMPLEX).setComplexColumn(new ComplexColumnPartSupplier((GenericIndexed)metricHolder.complexType,metricHolder.getTypeName())).build());
    }
  }
  Set<String> colSet=Sets.newTreeSet();
  colSet.addAll(Lists.newArrayList(index.getAvailableDimensions()));
  colSet.addAll(Lists.newArrayList(index.getAvailableMetrics()));
  String[] cols=colSet.toArray(new String[colSet.size()]);
  return new SimpleQueryableIndex(index.getDataInterval(),new ArrayIndexed<String>(cols,String.class),index.getAvailableDimensions(),new ColumnBuilder().setType(ValueType.LONG).setGenericColumn(new LongGenericColumnSupplier(index.timestamps)).build(),columns);
}
