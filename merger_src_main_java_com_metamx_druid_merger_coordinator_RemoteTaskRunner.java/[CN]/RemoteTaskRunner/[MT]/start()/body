{
  try {
    workerPathCache.start();
    workerPathCache.getListenable().addListener(new PathChildrenCacheListener(){
      @Override public void childEvent(      CuratorFramework client,      final PathChildrenCacheEvent event) throws Exception {
        final Worker worker=jsonMapper.readValue(event.getData().getData(),Worker.class);
        if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) {
          log.info("New worker[%s] found!",worker.getHost());
          addWorker(worker);
        }
 else         if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {
          log.info("Worker[%s] removed!",worker.getHost());
          removeWorker(worker.getHost());
        }
      }
    }
);
    Period period=new Period(config.getTerminateResourcesDuration());
    PeriodGranularity granularity=new PeriodGranularity(period,config.getTerminateResourcesOriginDateTime(),null);
    final long startTime=granularity.next(granularity.truncate(new DateTime().getMillis()));
    ScheduledExecutors.scheduleAtFixedRate(scheduledExec,new Duration(System.currentTimeMillis(),startTime),config.getTerminateResourcesDuration(),new Runnable(){
      @Override public void run(){
        if (currentlyTerminating.isEmpty()) {
          if (zkWorkers.size() <= config.getMinNumWorkers()) {
            return;
          }
          List<WorkerWrapper> thoseLazyWorkers=Lists.newArrayList(FunctionalIterable.create(zkWorkers.values()).filter(new Predicate<WorkerWrapper>(){
            @Override public boolean apply(            @Nullable WorkerWrapper input){
              return input.getRunningTasks().isEmpty() && System.currentTimeMillis() - input.getLastCompletedTaskTime().getMillis() > config.getmaxWorkerIdleTimeMillisBeforeDeletion();
            }
          }
));
          AutoScalingData terminated=strategy.terminate(Lists.transform(thoseLazyWorkers,new Function<WorkerWrapper,String>(){
            @Override public String apply(            @Nullable WorkerWrapper input){
              return input.getWorker().getHost();
            }
          }
));
          if (terminated != null) {
            currentlyTerminating.addAll(terminated.getNodeIds());
          }
        }
 else {
          log.info("[%s] still terminating. Wait for all nodes to terminate before trying again.",currentlyTerminating);
        }
      }
    }
);
    started=true;
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
}
