{
  try {
    final MinMaxPriorityQueue<WorkerWrapper> workerQueue=MinMaxPriorityQueue.<WorkerWrapper>orderedBy(new Comparator<WorkerWrapper>(){
      @Override public int compare(      WorkerWrapper w1,      WorkerWrapper w2){
        return -Ints.compare(w1.getRunningTasks().size(),w2.getRunningTasks().size());
      }
    }
).create(FunctionalIterable.create(zkWorkers.values()).filter(new Predicate<WorkerWrapper>(){
      @Override public boolean apply(      WorkerWrapper input){
        return (!input.isAtCapacity() && input.getWorker().getVersion().compareTo(config.getMinWorkerVersion()) >= 0);
      }
    }
));
    if (workerQueue.isEmpty()) {
      log.makeAlert("There are no worker nodes with capacity to run task!").emit();
      strategy.provisionIfNeeded(zkWorkers);
      return null;
    }
    return workerQueue.peek();
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
}
