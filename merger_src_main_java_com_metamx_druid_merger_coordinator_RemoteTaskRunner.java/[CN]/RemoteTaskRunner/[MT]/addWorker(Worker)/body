{
  try {
    currentlyProvisioning.remove(worker.getHost());
    final String workerStatusPath=JOINER.join(config.getStatusPath(),worker.getHost());
    final PathChildrenCache statusCache=new PathChildrenCache(cf,workerStatusPath,true);
    final WorkerWrapper workerWrapper=new WorkerWrapper(worker,statusCache,jsonMapper);
    statusCache.getListenable().addListener(new PathChildrenCacheListener(){
      @Override public void childEvent(      CuratorFramework client,      PathChildrenCacheEvent event) throws Exception {
synchronized (statusLock) {
          try {
            if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED) || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {
              final String taskId=ZKPaths.getNodeFromPath(event.getData().getPath());
              final TaskStatus taskStatus;
              try {
                taskStatus=jsonMapper.readValue(event.getData().getData(),TaskStatus.class);
                if (!taskStatus.getId().equals(taskId)) {
                  throw new ISE("Worker[%s] status id does not match payload id: %s != %s",worker.getHost(),taskId,taskStatus.getId());
                }
              }
 catch (              Exception e) {
                log.warn(e,"Worker[%s] wrote bogus status for task: %s",worker.getHost(),taskId);
                retryTask(new CleanupPaths(worker.getHost(),taskId),tasks.get(taskId));
                throw Throwables.propagate(e);
              }
              log.info("Worker[%s] wrote %s status for task: %s",worker.getHost(),taskStatus.getStatusCode(),taskId);
              statusLock.notify();
              if (taskStatus.isComplete()) {
                workerWrapper.setLastCompletedTaskTime(new DateTime());
                final TaskWrapper taskWrapper=tasks.get(taskId);
                if (taskWrapper == null) {
                  log.warn("WTF?! Worker[%s] completed a task I didn't know about: %s",worker.getHost(),taskId);
                }
 else {
                  final TaskCallback callback=taskWrapper.getCallback();
                  if (callback != null) {
                    callback.notify(taskStatus);
                  }
                  tasks.remove(taskId);
                  cf.delete().guaranteed().inBackground().forPath(event.getData().getPath());
                }
              }
            }
          }
 catch (          Exception e) {
            log.makeAlert(e,"Failed to handle new worker status").addData("worker",worker.getHost()).addData("znode",event.getData().getPath()).emit();
          }
        }
      }
    }
);
    zkWorkers.put(worker.getHost(),workerWrapper);
    statusCache.start();
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
}
