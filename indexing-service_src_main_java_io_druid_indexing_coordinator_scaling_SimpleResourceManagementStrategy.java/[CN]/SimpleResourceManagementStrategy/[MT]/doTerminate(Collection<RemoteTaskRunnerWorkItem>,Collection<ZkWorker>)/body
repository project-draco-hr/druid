{
  Set<String> workerNodeIds=Sets.newHashSet(autoScalingStrategy.ipToIdLookup(Lists.newArrayList(Iterables.transform(zkWorkers,new Function<ZkWorker,String>(){
    @Override public String apply(    ZkWorker input){
      return input.getWorker().getIp();
    }
  }
))));
  Set<String> stillExisting=Sets.newHashSet();
  for (  String s : currentlyTerminating) {
    if (workerNodeIds.contains(s)) {
      stillExisting.add(s);
    }
  }
  currentlyTerminating.clear();
  currentlyTerminating.addAll(stillExisting);
  boolean nothingTerminating=currentlyTerminating.isEmpty();
  if (nothingTerminating) {
    final int minNumWorkers=workerSetupdDataRef.get().getMinNumWorkers();
    if (zkWorkers.size() <= minNumWorkers) {
      log.info("Only [%d <= %d] nodes in the cluster, not terminating anything.",zkWorkers.size(),minNumWorkers);
      return false;
    }
    List<ZkWorker> thoseLazyWorkers=Lists.newArrayList(FunctionalIterable.create(zkWorkers).filter(new Predicate<ZkWorker>(){
      @Override public boolean apply(      ZkWorker input){
        return input.getRunningTasks().isEmpty() && System.currentTimeMillis() - input.getLastCompletedTaskTime().getMillis() >= config.getWorkerIdleTimeout().getMillis();
      }
    }
));
    int maxPossibleNodesTerminated=zkWorkers.size() - minNumWorkers;
    int numNodesToTerminate=Math.min(maxPossibleNodesTerminated,thoseLazyWorkers.size());
    if (numNodesToTerminate <= 0) {
      log.info("Found no nodes to terminate.");
      return false;
    }
    AutoScalingData terminated=autoScalingStrategy.terminate(Lists.transform(thoseLazyWorkers.subList(0,numNodesToTerminate),new Function<ZkWorker,String>(){
      @Override public String apply(      ZkWorker input){
        return input.getWorker().getIp();
      }
    }
));
    if (terminated != null) {
      currentlyTerminating.addAll(terminated.getNodeIds());
      lastTerminateTime=new DateTime();
      scalingStats.addTerminateEvent(terminated);
      return true;
    }
  }
 else {
    Duration durSinceLastTerminate=new Duration(lastTerminateTime,new DateTime());
    log.info("%s still terminating. Wait for all nodes to terminate before trying again.",currentlyTerminating);
    if (durSinceLastTerminate.isLongerThan(config.getMaxScalingDuration().toStandardDuration())) {
      log.makeAlert("Worker node termination taking too long!").addData("millisSinceLastTerminate",durSinceLastTerminate.getMillis()).addData("terminatingCount",currentlyTerminating.size()).emit();
      currentlyTerminating.clear();
    }
  }
  return false;
}
