{
  replicatorThrottler.updateParams(coordinator.getDynamicConfigs().getReplicationThrottleLimit(),coordinator.getDynamicConfigs().getReplicantLifetime());
  CoordinatorStats stats=new CoordinatorStats();
  DruidCluster cluster=params.getDruidCluster();
  if (cluster.isEmpty()) {
    log.warn("Uh... I have no servers. Not assigning anything...");
    return params;
  }
  for (  String tier : cluster.getTierNames()) {
    replicatorThrottler.updateReplicationState(tier);
    replicatorThrottler.updateTerminationState(tier);
  }
  DruidCoordinatorRuntimeParams paramsWithReplicationManager=params.buildFromExisting().withReplicationManager(replicatorThrottler).build();
  DateTime now=new DateTime();
  MetadataRuleManager databaseRuleManager=paramsWithReplicationManager.getDatabaseRuleManager();
  final Map<String,Set<String>> missingRules=Maps.newHashMap();
  for (  DataSegment segment : paramsWithReplicationManager.getAvailableSegments()) {
    List<Rule> rules=databaseRuleManager.getRulesWithDefault(segment.getDataSource());
    boolean foundMatchingRule=false;
    for (    Rule rule : rules) {
      if (rule.appliesTo(segment,now)) {
        stats.accumulate(rule.run(coordinator,paramsWithReplicationManager,segment));
        foundMatchingRule=true;
        break;
      }
    }
    if (!foundMatchingRule) {
      Set<String> missingSegments=missingRules.get(segment.getDataSource());
      if (missingSegments == null) {
        missingSegments=Sets.newHashSet();
        missingRules.put(segment.getDataSource(),missingSegments);
      }
      missingSegments.add(segment.getIdentifier());
    }
  }
  if (!missingRules.isEmpty()) {
    log.makeAlert("Unable to find a matching rules!").addData("missingSegments",missingRules).emit();
  }
  return paramsWithReplicationManager.buildFromExisting().withCoordinatorStats(stats).build();
}
