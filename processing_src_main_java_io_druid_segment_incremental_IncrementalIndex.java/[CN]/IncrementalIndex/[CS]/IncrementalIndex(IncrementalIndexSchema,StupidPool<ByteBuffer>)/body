{
  this.minTimestamp=incrementalIndexSchema.getMinTimestamp();
  this.gran=incrementalIndexSchema.getGran();
  this.metrics=incrementalIndexSchema.getMetrics();
  final ImmutableList.Builder<String> metricNamesBuilder=ImmutableList.builder();
  final ImmutableMap.Builder<String,Integer> metricIndexesBuilder=ImmutableMap.builder();
  final ImmutableMap.Builder<String,String> metricTypesBuilder=ImmutableMap.builder();
  this.aggs=new BufferAggregator[metrics.length];
  this.aggPositionOffsets=new int[metrics.length];
  int currAggSize=0;
  for (int i=0; i < metrics.length; i++) {
    final AggregatorFactory agg=metrics[i];
    aggs[i]=agg.factorizeBuffered(new ColumnSelectorFactory(){
      @Override public TimestampColumnSelector makeTimestampColumnSelector(){
        return new TimestampColumnSelector(){
          @Override public long getTimestamp(){
            return in.get().getTimestampFromEpoch();
          }
        }
;
      }
      @Override public FloatColumnSelector makeFloatColumnSelector(      String columnName){
        final String metricName=columnName.toLowerCase();
        return new FloatColumnSelector(){
          @Override public float get(){
            return in.get().getFloatMetric(metricName);
          }
        }
;
      }
      @Override public ObjectColumnSelector makeObjectColumnSelector(      String column){
        final String typeName=agg.getTypeName();
        final String columnName=column.toLowerCase();
        if (typeName.equals("float")) {
          return new ObjectColumnSelector<Float>(){
            @Override public Class classOfObject(){
              return Float.TYPE;
            }
            @Override public Float get(){
              return in.get().getFloatMetric(columnName);
            }
          }
;
        }
        final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(typeName);
        if (serde == null) {
          throw new ISE("Don't know how to handle type[%s]",typeName);
        }
        final ComplexMetricExtractor extractor=serde.getExtractor();
        return new ObjectColumnSelector(){
          @Override public Class classOfObject(){
            return extractor.extractedClass();
          }
          @Override public Object get(){
            return extractor.extractValue(in.get(),columnName);
          }
        }
;
      }
      @Override public DimensionSelector makeDimensionSelector(      String dimension){
        throw new UnsupportedOperationException("Incremental index aggregation does not support dimension selectors");
      }
    }
);
    aggPositionOffsets[i]=currAggSize;
    currAggSize+=agg.getMaxIntermediateSize();
    final String metricName=metrics[i].getName().toLowerCase();
    metricNamesBuilder.add(metricName);
    metricIndexesBuilder.put(metricName,i);
    metricTypesBuilder.put(metricName,metrics[i].getTypeName());
  }
  metricNames=metricNamesBuilder.build();
  metricIndexes=metricIndexesBuilder.build();
  metricTypes=metricTypesBuilder.build();
  this.totalAggSize=currAggSize;
  this.dimensionOrder=Maps.newLinkedHashMap();
  this.dimensions=new CopyOnWriteArrayList<String>();
  int index=0;
  for (  String dim : incrementalIndexSchema.getDimensions()) {
    dimensionOrder.put(dim,index++);
    dimensions.add(dim);
  }
  this.spatialDimensions=incrementalIndexSchema.getSpatialDimensions();
  this.spatialDimensionRowFormatter=new SpatialDimensionRowFormatter(spatialDimensions);
  this.bufferHolder=bufferPool.take();
  this.dimValues=new DimensionHolder();
  this.facts=new ConcurrentSkipListMap<TimeAndDims,Integer>();
}
