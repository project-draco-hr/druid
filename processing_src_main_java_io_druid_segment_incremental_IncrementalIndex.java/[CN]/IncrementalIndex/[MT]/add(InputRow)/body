{
  row=spatialDimensionRowFormatter.formatRow(row);
  if (row.getTimestampFromEpoch() < minTimestamp) {
    throw new IAE("Cannot add row[%s] because it is below the minTimestamp[%s]",row,new DateTime(minTimestamp));
  }
  final List<String> rowDimensions=row.getDimensions();
  String[][] dims=new String[dimensionOrder.size()][];
  List<String[]> overflow=null;
  for (  String dimension : rowDimensions) {
    dimension=dimension.toLowerCase();
    List<String> dimensionValues=row.getDimension(dimension);
    final Integer index=dimensionOrder.get(dimension);
    if (index == null) {
      dimensionOrder.put(dimension,dimensionOrder.size());
      dimensions.add(dimension);
      if (overflow == null) {
        overflow=Lists.newArrayList();
      }
      overflow.add(getDimVals(dimValues.add(dimension),dimensionValues));
    }
 else {
      dims[index]=getDimVals(dimValues.get(dimension),dimensionValues);
    }
  }
  if (overflow != null) {
    String[][] newDims=new String[dims.length + overflow.size()][];
    System.arraycopy(dims,0,newDims,0,dims.length);
    for (int i=0; i < overflow.size(); ++i) {
      newDims[dims.length + i]=overflow.get(i);
    }
    dims=newDims;
  }
  TimeAndDims key=new TimeAndDims(Math.max(gran.truncate(row.getTimestampFromEpoch()),minTimestamp),dims);
  in=row;
  Aggregator[] aggs=facts.get(key);
  if (aggs == null) {
    aggs=new Aggregator[metrics.length];
    for (int i=0; i < metrics.length; ++i) {
      final AggregatorFactory agg=metrics[i];
      aggs[i]=agg.factorize(new ColumnSelectorFactory(){
        @Override public FloatColumnSelector makeFloatColumnSelector(        String columnName){
          final String metricName=columnName.toLowerCase();
          return new FloatColumnSelector(){
            @Override public float get(){
              return in.getFloatMetric(metricName);
            }
          }
;
        }
        @Override public ObjectColumnSelector makeObjectColumnSelector(        String column){
          final String typeName=agg.getTypeName();
          final String columnName=column.toLowerCase();
          if (typeName.equals("float")) {
            return new ObjectColumnSelector<Float>(){
              @Override public Class classOfObject(){
                return Float.TYPE;
              }
              @Override public Float get(){
                return in.getFloatMetric(columnName);
              }
            }
;
          }
          final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(typeName);
          if (serde == null) {
            throw new ISE("Don't know how to handle type[%s]",typeName);
          }
          final ComplexMetricExtractor extractor=serde.getExtractor();
          return new ObjectColumnSelector(){
            @Override public Class classOfObject(){
              return extractor.extractedClass();
            }
            @Override public Object get(){
              return extractor.extractValue(in,columnName);
            }
          }
;
        }
      }
);
    }
    facts.put(key,aggs);
    ++numEntries;
  }
  for (  Aggregator agg : aggs) {
    agg.aggregate();
  }
  in=null;
  return numEntries;
}
