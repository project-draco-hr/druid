{
  row=spatialDimensionRowFormatter.formatRow(row);
  if (row.getTimestampFromEpoch() < minTimestamp) {
    throw new IAE("Cannot add row[%s] because it is below the minTimestamp[%s]",row,new DateTime(minTimestamp));
  }
  final List<String> rowDimensions=row.getDimensions();
  String[][] dims;
  List<String[]> overflow=null;
synchronized (dimensionOrder) {
    dims=new String[dimensionOrder.size()][];
    for (    String dimension : rowDimensions) {
      dimension=dimension.toLowerCase();
      List<String> dimensionValues=row.getDimension(dimension);
      Integer index=dimensionOrder.get(dimension);
      if (index == null) {
        dimensionOrder.put(dimension,dimensionOrder.size());
        dimensions.add(dimension);
        if (overflow == null) {
          overflow=Lists.newArrayList();
        }
        overflow.add(getDimVals(dimValues.add(dimension),dimensionValues));
      }
 else {
        dims[index]=getDimVals(dimValues.get(dimension),dimensionValues);
      }
    }
  }
  if (overflow != null) {
    String[][] newDims=new String[dims.length + overflow.size()][];
    System.arraycopy(dims,0,newDims,0,dims.length);
    for (int i=0; i < overflow.size(); ++i) {
      newDims[dims.length + i]=overflow.get(i);
    }
    dims=newDims;
  }
  TimeAndDims key=new TimeAndDims(Math.max(gran.truncate(row.getTimestampFromEpoch()),minTimestamp),dims);
  Aggregator[] aggs=facts.get(key);
  if (aggs == null) {
    aggs=new Aggregator[metrics.length];
    for (int i=0; i < metrics.length; ++i) {
      final AggregatorFactory agg=metrics[i];
      aggs[i]=agg.factorize(new ColumnSelectorFactory(){
        @Override public TimestampColumnSelector makeTimestampColumnSelector(){
          return new TimestampColumnSelector(){
            @Override public long getTimestamp(){
              return in.getTimestampFromEpoch();
            }
          }
;
        }
        @Override public FloatColumnSelector makeFloatColumnSelector(        String columnName){
          final String metricName=columnName.toLowerCase();
          return new FloatColumnSelector(){
            @Override public float get(){
              return in.getFloatMetric(metricName);
            }
          }
;
        }
        @Override public ObjectColumnSelector makeObjectColumnSelector(        String column){
          final String typeName=agg.getTypeName();
          final String columnName=column.toLowerCase();
          if (typeName.equals("float")) {
            return new ObjectColumnSelector<Float>(){
              @Override public Class classOfObject(){
                return Float.TYPE;
              }
              @Override public Float get(){
                return in.getFloatMetric(columnName);
              }
            }
;
          }
          final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(typeName);
          if (serde == null) {
            throw new ISE("Don't know how to handle type[%s]",typeName);
          }
          final ComplexMetricExtractor extractor=serde.getExtractor();
          return new ObjectColumnSelector(){
            @Override public Class classOfObject(){
              return extractor.extractedClass();
            }
            @Override public Object get(){
              return extractor.extractValue(in,columnName);
            }
          }
;
        }
        @Override public DimensionSelector makeDimensionSelector(        String dimension){
          throw new UnsupportedOperationException("Incremental index aggregation does not support dimension selectors");
        }
      }
);
    }
    Aggregator[] prev=facts.putIfAbsent(key,aggs);
    if (prev != null) {
      aggs=prev;
    }
 else {
      numEntries.incrementAndGet();
    }
  }
synchronized (this) {
    in=row;
    for (    Aggregator agg : aggs) {
      agg.aggregate();
    }
    in=null;
  }
  return numEntries.get();
}
