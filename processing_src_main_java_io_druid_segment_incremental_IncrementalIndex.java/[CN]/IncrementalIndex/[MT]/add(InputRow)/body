{
  row=spatialDimensionRowFormatter.formatRow(row);
  if (row.getTimestampFromEpoch() < minTimestamp) {
    throw new IAE("Cannot add row[%s] because it is below the minTimestamp[%s]",row,new DateTime(minTimestamp));
  }
  final List<String> rowDimensions=row.getDimensions();
  String[][] dims;
  List<String[]> overflow=null;
synchronized (dimensionOrder) {
    dims=new String[dimensionOrder.size()][];
    for (    String dimension : rowDimensions) {
      dimension=dimension.toLowerCase();
      List<String> dimensionValues=row.getDimension(dimension);
      Integer index=dimensionOrder.get(dimension);
      if (index == null) {
        dimensionOrder.put(dimension,dimensionOrder.size());
        dimensions.add(dimension);
        if (overflow == null) {
          overflow=Lists.newArrayList();
        }
        overflow.add(getDimVals(dimValues.add(dimension),dimensionValues));
      }
 else {
        dims[index]=getDimVals(dimValues.get(dimension),dimensionValues);
      }
    }
  }
  if (overflow != null) {
    String[][] newDims=new String[dims.length + overflow.size()][];
    System.arraycopy(dims,0,newDims,0,dims.length);
    for (int i=0; i < overflow.size(); ++i) {
      newDims[dims.length + i]=overflow.get(i);
    }
    dims=newDims;
  }
  final TimeAndDims key=new TimeAndDims(Math.max(gran.truncate(row.getTimestampFromEpoch()),minTimestamp),dims);
  Aggregator[] aggs=facts.get(key);
  if (aggs == null) {
    aggs=new Aggregator[metrics.length];
    for (int i=0; i < metrics.length; ++i) {
      final AggregatorFactory agg=metrics[i];
      aggs[i]=agg.factorize(new ColumnSelectorFactory(){
        @Override public TimestampColumnSelector makeTimestampColumnSelector(){
          return new TimestampColumnSelector(){
            @Override public long getTimestamp(){
              return in.getTimestampFromEpoch();
            }
          }
;
        }
        @Override public FloatColumnSelector makeFloatColumnSelector(        String columnName){
          final String metricName=columnName.toLowerCase();
          return new FloatColumnSelector(){
            @Override public float get(){
              return in.getFloatMetric(metricName);
            }
          }
;
        }
        @Override public ObjectColumnSelector makeObjectColumnSelector(        String column){
          final String typeName=agg.getTypeName();
          final String columnName=column.toLowerCase();
          if (typeName.equals("float")) {
            return new ObjectColumnSelector<Float>(){
              @Override public Class classOfObject(){
                return Float.TYPE;
              }
              @Override public Float get(){
                return in.getFloatMetric(columnName);
              }
            }
;
          }
          final List<String> dimensionValues=in.getDimension(columnName);
          if (dimensionValues != null) {
            return new ObjectColumnSelector<Object>(){
              @Override public Class classOfObject(){
                return Object.class;
              }
              @Override public Object get(){
                final String[] dimVals=dimensionValues.toArray(new String[]{});
                if (dimVals.length == 1) {
                  return dimVals[0];
                }
 else                 if (dimVals.length == 0) {
                  return null;
                }
 else {
                  return dimVals;
                }
              }
            }
;
          }
          final ComplexMetricSerde serde=ComplexMetrics.getSerdeForType(typeName);
          if (serde == null) {
            throw new ISE("Don't know how to handle type[%s]",typeName);
          }
          final ComplexMetricExtractor extractor=serde.getExtractor();
          return new ObjectColumnSelector(){
            @Override public Class classOfObject(){
              return extractor.extractedClass();
            }
            @Override public Object get(){
              return extractor.extractValue(in,columnName);
            }
          }
;
        }
        @Override public DimensionSelector makeDimensionSelector(        final String dimension){
          final String dimensionName=dimension.toLowerCase();
          final List<String> dimensionValues=in.getDimension(dimensionName);
          if (dimensionValues == null) {
            return null;
          }
          final IncrementalIndex.DimDim dimValLookup=getDimension(dimensionName);
          final int maxId=dimValLookup.size();
          return new DimensionSelector(){
            @Override public IndexedInts getRow(){
              final ArrayList<Integer> vals=Lists.newArrayList();
              for (              String dimVal : dimensionValues) {
                int id=dimValLookup.getId(dimVal);
                vals.add(id);
              }
              return new IndexedInts(){
                @Override public int size(){
                  return vals.size();
                }
                @Override public int get(                int index){
                  return vals.get(index);
                }
                @Override public Iterator<Integer> iterator(){
                  return vals.iterator();
                }
              }
;
            }
            @Override public int getValueCardinality(){
              return maxId;
            }
            @Override public String lookupName(            int id){
              return dimValLookup.getValue(id);
            }
            @Override public int lookupId(            String name){
              return dimValLookup.getId(name);
            }
          }
;
        }
      }
);
    }
    Aggregator[] prev=facts.putIfAbsent(key,aggs);
    if (prev != null) {
      aggs=prev;
    }
 else {
      numEntries.incrementAndGet();
    }
  }
synchronized (this) {
    in=row;
    for (    Aggregator agg : aggs) {
      agg.aggregate();
    }
    in=null;
  }
  return numEntries.get();
}
