{
  return new Iterable<Row>(){
    @Override public Iterator<Row> iterator(){
      final List<DimensionDesc> dimensions=getDimensions();
      Map<TimeAndDims,Integer> facts=null;
      if (descending && sortFacts) {
        facts=((ConcurrentNavigableMap<TimeAndDims,Integer>)getFacts()).descendingMap();
      }
 else {
        facts=getFacts();
      }
      return Iterators.transform(facts.entrySet().iterator(),new Function<Map.Entry<TimeAndDims,Integer>,Row>(){
        @Override public Row apply(        final Map.Entry<TimeAndDims,Integer> input){
          final TimeAndDims timeAndDims=input.getKey();
          final int rowOffset=input.getValue();
          int[][] theDims=timeAndDims.getDims();
          ValueType[] types=timeAndDims.getTypes();
          Map<String,Object> theVals=Maps.newLinkedHashMap();
          for (int i=0; i < theDims.length; ++i) {
            int[] dim=theDims[i];
            ValueType type=types[i];
            DimensionDesc dimensionDesc=dimensions.get(i);
            if (dimensionDesc == null) {
              continue;
            }
            String dimensionName=dimensionDesc.getName();
            if (dim == null || dim.length == 0) {
              theVals.put(dimensionName,null);
              continue;
            }
            if (dim.length == 1) {
              Comparable val=dimensionDesc.getValues().getValue(dim[0]);
              if (type == ValueType.STRING) {
                val=Strings.nullToEmpty((String)val);
              }
              theVals.put(dimensionName,val);
            }
 else {
              Comparable[] dimVals=new Comparable[dim.length];
              for (int j=0; j < dimVals.length; j++) {
                Comparable val=dimensionDesc.getValues().getValue(dim[j]);
                if (type == ValueType.STRING) {
                  val=Strings.nullToEmpty((String)val);
                }
                dimVals[j]=val;
              }
              theVals.put(dimensionName,dimVals);
            }
          }
          AggregatorType[] aggs=getAggsForRow(rowOffset);
          for (int i=0; i < aggs.length; ++i) {
            theVals.put(metrics[i].getName(),getAggVal(aggs[i],rowOffset,i));
          }
          if (postAggs != null) {
            for (            PostAggregator postAgg : postAggs) {
              theVals.put(postAgg.getName(),postAgg.compute(theVals));
            }
          }
          return new MapBasedRow(timeAndDims.getTimestamp(),theVals);
        }
      }
);
    }
  }
;
}
