{
  return new BaseSequence<Result<TimeseriesResultValue>,Iterator<Result<TimeseriesResultValue>>>(new BaseSequence.IteratorMaker<Result<TimeseriesResultValue>,Iterator<Result<TimeseriesResultValue>>>(){
    @Override public Iterator<Result<TimeseriesResultValue>> make(){
      return QueryRunnerHelper.makeCursorBasedQuery(adapter,query.getQuerySegmentSpec().getIntervals(),Filters.convertDimensionFilters(query.getDimensionsFilter()),query.getGranularity(),new Function<Cursor,Result<TimeseriesResultValue>>(){
        private final List<AggregatorFactory> aggregatorSpecs=query.getAggregatorSpecs();
        private final List<PostAggregator> postAggregatorSpecs=query.getPostAggregatorSpecs();
        @Override public Result<TimeseriesResultValue> apply(        Cursor cursor){
          Aggregator[] aggregators=QueryRunnerHelper.makeAggregators(cursor,aggregatorSpecs);
          while (!cursor.isDone()) {
            for (            Aggregator aggregator : aggregators) {
              aggregator.aggregate();
            }
            cursor.advance();
          }
          TimeseriesResultBuilder bob=new TimeseriesResultBuilder(cursor.getTime());
          for (          Aggregator aggregator : aggregators) {
            bob.addMetric(aggregator);
          }
          for (          PostAggregator postAgg : postAggregatorSpecs) {
            bob.addMetric(postAgg);
          }
          Result<TimeseriesResultValue> retVal=bob.build();
          for (          Aggregator agg : aggregators)           agg.close();
          return retVal;
        }
      }
).iterator();
    }
    @Override public void cleanup(    Iterator<Result<TimeseriesResultValue>> toClean){
      while (toClean.hasNext()) {
        toClean.next();
      }
    }
  }
);
}
