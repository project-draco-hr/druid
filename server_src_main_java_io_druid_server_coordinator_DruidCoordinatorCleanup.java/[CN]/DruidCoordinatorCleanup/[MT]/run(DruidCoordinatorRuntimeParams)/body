{
  CoordinatorStats stats=new CoordinatorStats();
  Set<DataSegment> availableSegments=params.getAvailableSegments();
  DruidCluster cluster=params.getDruidCluster();
  for (  MinMaxPriorityQueue<ServerHolder> serverHolders : cluster.getSortedServersByTier()) {
    for (    ServerHolder serverHolder : serverHolders) {
      DruidServer server=serverHolder.getServer();
      for (      DruidDataSource dataSource : server.getDataSources()) {
        for (        DataSegment segment : dataSource.getSegments()) {
          if (!availableSegments.contains(segment)) {
            LoadQueuePeon queuePeon=params.getLoadManagementPeons().get(server.getName());
            if (!queuePeon.getSegmentsToDrop().contains(segment)) {
              queuePeon.dropSegment(segment,new LoadPeonCallback(){
                @Override protected void execute(){
                }
              }
);
              stats.addToTieredStat("unneededCount",server.getTier(),1);
            }
          }
        }
      }
    }
  }
  if (params.hasDeletionWaitTimeElapsed()) {
    Map<String,VersionedIntervalTimeline<String,DataSegment>> timelines=Maps.newHashMap();
    for (    MinMaxPriorityQueue<ServerHolder> serverHolders : cluster.getSortedServersByTier()) {
      for (      ServerHolder serverHolder : serverHolders) {
        DruidServer server=serverHolder.getServer();
        for (        DruidDataSource dataSource : server.getDataSources()) {
          VersionedIntervalTimeline<String,DataSegment> timeline=timelines.get(dataSource.getName());
          if (timeline == null) {
            timeline=new VersionedIntervalTimeline<String,DataSegment>(Comparators.comparable());
            timelines.put(dataSource.getName(),timeline);
          }
          for (          DataSegment segment : dataSource.getSegments()) {
            timeline.add(segment.getInterval(),segment.getVersion(),segment.getShardSpec().createChunk(segment));
          }
        }
      }
    }
    for (    VersionedIntervalTimeline<String,DataSegment> timeline : timelines.values()) {
      for (      TimelineObjectHolder<String,DataSegment> holder : timeline.findOvershadowed()) {
        for (        DataSegment dataSegment : holder.getObject().payloads()) {
          coordinator.removeSegment(dataSegment);
          stats.addToGlobalStat("overShadowedCount",1);
        }
      }
    }
  }
  return params.buildFromExisting().withCoordinatorStats(stats).build();
}
