{
  int assignedCount=0;
  int unassignedCount=0;
  long unassignedSize=0;
  int expectedReplicants=getReplicationFactor();
  int actualReplicants=params.getSegmentReplicantLookup().lookup(segment.getIdentifier(),gettier());
  MinMaxPriorityQueue<ServerHolder> serverQueue=params.getDruidCluster().getServersByTier(gettier());
  if (serverQueue == null) {
    log.makeAlert("No holders found for tier[%s]",gettier()).emit();
    return new AssignStat(new Pair<String,Integer>(gettier(),0),0,0);
  }
  List<ServerHolder> assignedServers=Lists.newArrayList();
  while (actualReplicants < expectedReplicants) {
    ServerHolder holder=serverQueue.pollFirst();
    if (holder == null) {
      log.warn("Not enough %s servers[%d] to assign segments!!!",gettier(),serverQueue.size());
      break;
    }
    if (holder.containsSegment(segment)) {
      continue;
    }
    if (holder.getAvailableSize() < segment.getSize()) {
      log.warn("Not enough node capacity, closest is [%s] with %,d available, skipping segment[%s].",holder.getServer(),holder.getAvailableSize(),segment);
      params.getEmitter().emit(new AlertEvent.Builder().build("Not enough node capacity",ImmutableMap.<String,Object>builder().put("segmentSkipped",segment.toString()).put("closestNode",holder.getServer().toString()).put("availableSize",holder.getAvailableSize()).build()));
      serverQueue.add(holder);
      unassignedCount++;
      unassignedSize+=segment.getSize();
      break;
    }
    holder.getPeon().loadSegment(segment,new LoadPeonCallback(){
      @Override protected void execute(){
      }
    }
);
    assignedServers.add(holder);
    ++assignedCount;
    ++actualReplicants;
  }
  serverQueue.addAll(assignedServers);
  return new AssignStat(new Pair<String,Integer>(gettier(),assignedCount),unassignedCount,unassignedSize);
}
